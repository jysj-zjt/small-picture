# 计算机科学速成科课笔记

## 电脑中处理速度

​		寄存器>缓存区>内存>硬盘>网络

​		寄存器的大小为4字节。

## （一）P1--P10

博客地址：https://www.yunliyunwai.cn/blog/detail/95e1dc8367ad72973b31ebca32a1f9f1

### P2	电子计算机

#### 1.计算机开关的发展

​		继电器-->真空管-->晶体管

### P3	布尔逻辑和逻辑门

#### 2.计算机使用二进制的原因

​		早期使用二进制中用晶体管的是否有电流通过将信息处理为真或假，也可以避免使用二以上的进制因为减少手机没电时周围电信号的干扰导致电流大小变化影响晶体管的判断；而且数学有一个专门研究真假问题的分支（布尔代数），并且它已经解决了所有的法则和运算。

#### 3.晶体管

​		晶体管有两根电极和一根控制线，当且仅当控制线有电流流过时两根电线才可以相通。

#### 4.布尔代数

##### 	1)NOT

​		NOT操作会把布尔值反转；

​		在晶体管中的使用：NOT门

​			如果将控制线认为是input，下部电线为output,如果输入为on，电流可流通，反之为off；但若果输出在上方的话就可以做到将输入与输出的值反转。

##### 	2)AND

​			AND为数学逻辑中的“且”

​			两个输入均为真时输出为真，其余皆为假；

​			两个晶体管连到一起，当且仅当两个均为on十点六才可以流通。

##### 	3)OR

​				数学逻辑中的“或”

##### 	4)XOR

​				只有输入的有真但不全为时方可输出真，当全为真时输出为false。

​				XOR的使用要多个不同的晶体管进行连接。

### P4	二进制

#### 5.字节

​		一般将二进制八位称为一个字节，一般换算使用1000或1024；

#### 6.现在的电脑的配置

​		现在常用的电脑一般是32位或者是64位的；

#### 7.数据计算方式

​		大部分计算的的32位中将第一位是为判断正负的，0为正，1为负可以表示正负20个亿（相当于0.2个天价98亿的2233手办，有这个就离谱)；

#### 8.地址

​		计算机会给内存中的每一个位置做一个“标记”，叫做位址，为了更方便的存取数据；

#### 9.非整数

​		非整数，也称作浮点数。常用IEEE  754标准（类似于科学计数法）表示。在32位的浮点数中，第一位存正负，接下来八位存指数，剩下的则存有效位数；

#### 10.ASCII

##### 		1)介绍

​				ASCII由美国发明，七位代码，不仅有大小写字母，标点符号和特殊字符，还有特殊命令符号；

##### 		2)优点

​				使不同计算机公司的数据可以互通

##### 		3)缺点

​				仅为英语设计

#### 11.一些代表性的英语词

​		mojibake    乱码

​		bug  			错误

#### 12.Unicode

​		Unicode用16位，统一了所有编码的标准；

### P5	算术逻辑单元

#### 13.表示和存储数字是计算机的重要功能；

#### 14.ALU

​		对数据的处理由计算机的“算术逻辑单元（简称ALU）”处理；

#### 15.半加器

​		原理：利用一个XOR和一个AND做出

​		XOR输出本位的结果，AND的结果是进位的结果，而且当两个均为true时AND输出true;

#### 16.全加器

​		原理：利用两个半加器和一个OR来实现

​		三个数据，A,B,C，先用第一个半加器对A和B运算，输出一个当前位X1，以及进一位X2，在用第二个半加器对X1和C进行运算，输出当前位以及进一位X3，用OR输出进一位的最后数据，X2与X3中一旦有一个是true，就输出true，即进一位结果为true。

#### 17.八位加法器

​		利用两数字当前位置上的两个数以及下面一位进上去的结果相加（第一位和最后一位另算），再将这三个数的当前位和进一位的数据输出，继续执行，直到计算到最高位上。第一位与上面的相比只是没有从下一位的进位；最高位的进位如果为true则为“溢出”   。

#### 18.逻辑单元

​		可以用来检测一个数字是否为零，当全为零时，OR并联的均为false，最后由NOT取反，即可以判断是否为零。

### P6	寄存器&内存

#### 19.存储信息

##### 		1)保存1的存储器

​			设置两个输入，A,B，连接上OR门，再将OR门的输出连到B上，使B的值与输出值相等，一旦A输入一个true，就会使得true被保存下来，不论A之后输入变为零，仍不变；

##### 		2)保存0的存储器

​				将(1)中的OR们换为AND即可。当A和B开始时都输入true时，AND的结果才为true，当A的输入变为false时，输出变为false。仅有A输入时，无论A为何值，均为false； 

##### 		3)AND-OR锁存器

​				将上述两个存储器结合到一起，有两个输入，一个为“设置”，一个叫“复位”。当设置为1，复位为0时，设置连接的OR门恒输出1到AND门，复位处的NOT门将0反转为1，AND们输出1，即存储了1；当设置为1，复位为1时，会因为复位处的反转致使AND门处输入不均为1，输出锁定0；当设置为0，复位为0时，结果为0；当设置为0，结果为0。它存住了一位的信息！

![image-20211124103306498](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124103306498.png)

#### 20.内存

​		![image-20211124104338754](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124104338754.png)

​			有一个允许写入线，当允许写入线关闭即为0时，无论数据的输入为多少，均会在AND1恒为0和AND2恒为0，之前存储的信息不会改变，在AND。当允许写入线打开即为1时，输入为1时，AND1门为1，由于对输入值反转，AND2门为0，再对AND2结果反转，去往AND3的值为1，AND1的值在OR中结果变为1，在AND3输出恒为为1，即存储下1的信息；当数据输入为0时，AND1结果为0，AND2结果为1，反转后到AND3值为0，最终AND3结果恒为0，即存储下0的信息。

#### 21.矩阵的应用

​		上面的仅可以容纳一个字节，但计算机的内存远远大于与一个字节，可以同时放置多个锁存器来存放更多的数据，但不可避免的就需要更多的线来连接。此时，矩阵很好地解决了这个问题，在矩形格内，当且仅当行线和列线均为1时，这个锁存器才可以使用，就可以只使用一条输入线，一条输出线，一条允许写入线，以及与之前相比少了很多的行线和列线。当想要使用哪个时，仅仅需要这个锁存器的行数和列数即可。

![image-20211124110655494](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124110655494.png)

![image-20211124110736113](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124110736113.png)

#### 22.多路复用器（1-16）

​		当输入数据，会将二进制的四位数据转化，并启用该数字对应的行列。对于上一个说到的矩阵，，则是由一个多路复用器处理行，再一个多路复用器去处理列。

#### 23.使用

​		上面说到的16x16矩阵可以存放256个字节，如果要存放更多的内容，利用下图的方式并联，每一个小的寄存器都有一个地址，256个寄存器可以读写256个8位值。

![image-20211124112639301](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124112639301.png)

#### 24.内存的一个重要特性

​		可以随时访问任何位置。 因此叫做“随机存取存储器”，简称RAM。仅可记录当前所在做的事，相当于是人的短期记忆。

### P7	中央处理器(CPU)

#### 25.CPU

​		全称为“Central Processing Unit”.

#### 26.所需的配置：

​		一个RAM，四个寄存器（A,B,C,D）（用来临时存数据和操作数据），本次将八位的二进制数的前四位作为操作代码，后四位的数代表数据来自哪里（寄存器或者内存地址），一个指令地址寄存器（储存当前指令的地址），指令寄存器（存当前指令）

#### 27.指令表

​			注：此处的指令表仅为例子，不代表CPU中的指令和这个相同

![image-20211124224334225](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124224334225.png)

​				LOAD_A即操作与寄存器A相关

​								将RAM中的值放到寄存器当中

​				LOAD_B即操作与寄存器B相关

​								从RAM里把一个值复制到寄存器B

​				STORE_A把A的值放入到内存当中

​								对A进行读取且对RAM进行写入，写入到指令后四位所表示的位置

​				ADD   对两个寄存器进行操作

​							后面四位两两代表一个寄存器，把前两个代表的寄存器内的数据加入到后一个寄存器中，控制单元选择正确的寄存器作为输入并配置ALU去执行正确的操作。控制单元传给ADD操作码行动，将前一个确定的寄存器作为第一个输入，后一个确定的寄存器作为第二个输入，再将结果存储到第二个确定的寄存器当中（注意不能直接将值写入到寄存器当中，否则会造成数值的不断相加。应先将ALU的结果计入到控制单元中的一个暂时的寄存器中，以保留数值，将ALU关闭后再把值从暂时的移到应该移到的地方。）

#### 28.执行阶段

​		在启动计算机时，所有的寄存器从0开始；

​		由时钟以精确的间隔触发电信号，推进CPU的内部操作，确保按照既定步骤进行。CPU“取指令-->解码-->执行”的速度叫“时钟速度”，单位为赫兹

##### 	1)阶段一：取指令

​		地址寄存器与RAM相连，使RAM返回地址寄存器当中所存的地址，对应的数据发送到指令寄存器当中

##### 	2)阶段二：解码

​		在指令表中查询指令时要进行什么操作

​			如：

​					解码操作：					

​			![image-20211124225510614](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211124225510614.png)

##### 			3)阶段三：结束本阶段

​					取地址寄存器数据+1，然后执行阶段本次结束，再回到阶段一重复。

### P8	(指令和程序)

#### 29.一个知识点

​			CPU这个硬件可以受软件控制操作。

#### 30.一些其他的指令

​		SUB--->减法，与加法类似；

​		JUMP--->跳转，让程序跳转到新位置，把指令后四位代表的内存地址覆盖掉“指令地址寄存器”里的值；

​		JUMP_NEGATIVE--->当且仅当ALU的负数标志为true的时候进行JUMP；

​		HALT--->计算机停止的指令

#### 31.指令和数据都是在同一个内存里的。

#### 32.增加表示的方法

​			对于之前八位指令，能表示的东西太少，可操作性较低，现代有两种解决方法：

​		1)用更多位（32/64）来表示指令，及增加指令长度（最直接的方法）；

​		2)可变指令长度

​			“立即值”：

#### 33.第一个CPU芯片

​		1971年，英特尔发布了4004处理器，第一次把CPU做成芯片，支持46个指令。

### P9	高级CPU设计

#### 34.早期计算机的提速方式

​			减少晶体管的切换时间

#### 35.现代计算机内的除法

​			直接进行除法的，不再是之前的一直做减法。

#### 36.RAM

​			RAM是CPU之外的独立部件，他们之间传输数据的线叫做总线。	

#### 37.新的问题

​		当时钟速度超快时，会带来一个新的问题：如何快读传递数据给CPU？（当从RAM中读取数据并传输时，会造成延迟，RAM需要找地址，取数据，配置，输出数据）

#### 38.解决方法

​		在CPU内添加缓存，RAM可以向缓存中存入一批数据，缓存在CPU内，一个时钟周期就能给数据，CPU不用空等。

​		如果要的数据在缓存中，叫做“缓存命中”，反之，叫做“缓存未命中”。

​		缓存也可以当临时空间，存一些中间值，适合长/复杂的运算。

​		缓存里每块空间都有一个特殊标记，叫做“脏位”。

​		同步一般发生在缓存满了而CPU又要缓存的时候。

​		在清空缓存之前会检查“脏位”，如果是“脏”，会在加载新东西之前，把数据写回到RAM当中。

#### 39.指令流水线（并行处理）

​			这是另一种提升性能的方法。

![image-20211125112849221](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211125112849221.png)

​		应先弄清楚数据间的依赖性，必要时停止流水线，避免出错。

​		动态排序、有依赖关系的指令可以最小化流水线的停工时间，叫做“乱序执行”。

​		对于条件跳转，高端CPU会对JUMP的下一个指令进行预测，并提前把指令放入到流水线中，叫做“推测执行”。当JUMP的结果出来后，若CPU猜对了，流水线继续执行，若猜错了，就清空流水线。

​		CPU厂商为CPU开发了复杂的方法去预测，叫做“分支预测”。

#### 40.另一种提升性能的方法

​			同时运行多个指令流，用多核处理器（一个CPU芯片内，有多个独立处理单元，可以分享一些资源，使其可以合作）。

### P10	早期的编程方式

#### 41.一点小知识点

​		复杂度vs速度  的平衡在计算机发展史上经常出现。

​		给机器编程最早出现在出现计算机之前。

​		演变：穿线纸卡-->插线板

​		插线板的缺点：执行不同的程序要重新接线

​		用纸卡的最大程序是美国空军SAGE防空系统（1955年建成）

62500张纸卡的数据大约是5MB

​		穿线卡纸不仅可以使计算机读入信息，也可以是计算机写出信息（打孔）。

​		不管是何种编程，早期的这些都是“专家活”，要求非常了解底层硬件。

#### 42.存储程序计算机

​			可以存运行的程序，甚至在内存足够的情况下，还可以存程序所需要的数据，包括程序运行时产生的新数据。这是冯诺依曼结构的计算机。

#### 43.冯诺依曼计算机

​			其的标志是，一个处理器（有算术逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令）。

#### 44.第一台冯诺依曼计算机

​			第一台冯诺依曼架构的“存储程序计算机”有曼彻斯特大学于1948年建造完成，绰号“宝宝”。程序与数据通过穿线纸卡输入。

#### 45.面板编程

​			即用一大堆开关和按钮达到编程的效果。

​			面板上的指示灯代表的是表格中函数的状态和内存中的值

#### 46.Altair  8800

​		Altair  8800是第一台取得商业成功的家用计算机。

​		使用8800是要通过面板上的开关输入二进制操作码，再按存储键把值存入内存，之后重复操作至指令全部输入完毕，推动开关使回到内存地址0，然后按运行按钮。

## （二）P11-P20

云里云外博客地址：https://www.yunliyunwai.cn/blog/detail/bc3c27106d72d071105d4a9df2ffaf99

### P11	编程语言发展史

#### 1.机器码

​		计算机的母语是二进制，但他们也只能读懂二进制，叫做“机器语言”或“机器码”。

#### 2.早期计算机使用方法

​		在计算机早期必须使用机器码来写程序，通常在纸上先写一个“高层次版”，再用“操作码表”把伪代码转化成为二进制机器码，再将写好的程序放入计算机并运行。

#### 3.伪代码

​			伪代码是对程序高层次的描述。

#### 4.助记符

​		再1940~1950年代，程序员开发出一种新语言，更可读 更高层次，给每个操作码分配一个简单的名字，叫做“助记符”，在助记符后紧跟上数据，来形成完整的指令。

#### 5.汇译器

​		汇编器可以将文字指令自动转化为二进制指令的二进制程序。

#### 6.JUMP的使用

​		自动分析JUMP地址：汇编器给程序中插入可跳转的标签。使程序员可以专心编程不用管底层细节，隐藏不必要细节来做更复杂的工作。

#### 7.第一个高级编程语言

​		葛丽丝**·**霍普设计了一个高级编程语言---“算术语言版本0”简称“A-0”。汇编与机器指令是一一对应的，但一行高级的编程语言可能会转成几十条二进制指令。于1952年创造了第一个编译器（专门把高级语言转化为低级语言）。

#### 8.A-0

​		A-0已完全遗失，没有任何遗留下来。

#### 9.变量

​		有了编译器，程序员只需要创建代表内存地址的抽象，叫“变量”。

#### 10.编程语言初期状况

​		刚开始的一些编程语言并没有广泛使用。1950年的大多数编程语言和编译器只能运行在一种计算机上。

#### 11.FORTRAN

​		这门语言于1957年由IBM发布，主宰了早期计算机编程。但只能在IBM的计算机上运行。

#### 12.第一门通用编程语言

​		1959年，为了改变现状，工业界、学术界、政府的计算机专家强强联手组建了一个联盟----数据系统委员会，由霍普担任顾问。为了开发一种可以在不同机器上通用的编程语言最终诞生了“普通面向商业语言”，简称COBOL。

#### 13.高级编程语言出现的影响

​		在高级编程语言出现之前，编程只会是主职的计算机专家和爱好者才会做的事，但现在，谁都可以使用计算机！！！

​		同时也使得计算机专家成为了现在的“专业程序员”，去制作更复杂的程序。

### P12	编程原理-语句和函数

#### 14.语法

​		规定句子结构的一系列规则叫语法。

#### 15.初始化

​		初始化的意思是设置最开始的量。

#### 16.函数

​		为了隐藏复杂度可以把代码打包成“函数”，也叫“方法”或“子程序”（有的编程语言这样命名），如果要使用这个函数，直接写函数名即可。

### P13	算法入门

#### 17.编程的本质

​		不同顺序写不同语句也能得到一样结果，其不同的是算法，意思是解决问题的具体步骤。

#### 18.计算机科学

​		如何想出高效的算法是计算机出现之前就问题诞生了专门研究计算的领域，然后发展成一门现代学科----计算机科学。

#### 19.排序

​		记载最多的算法之一是“排序”。

#### 20.选择排序

​		第n次循环：从第n项开始寻找到最后一位，将里面最小的那个与第n个数交换位置。

​		复杂度=O（N^2）；

#### 21.大O表示法

​		算法的输入大小和运行步骤之间的关系叫做算法的复杂度。表示运行速度的量级。表示的方法----大O表示法。

#### 22.归并排序

​		两两进行合并，进行内部排序，再将已合并的再两两进行合并排序（此时是比较两个数组的第一个数，知道数字全部排列完毕），直到全部合并。

​		算法复杂度：O（n*log n）n是需要比较+合并的次数，和数组大小成正比log N是合并步骤的次数。

#### 23.图搜索

​		从成本最低的节点开始，跑到所有相邻的节点，记录成本，为达到结束的条件，继续算法。当此次到达该节点时所消耗的大于之前所记录的最低，则不进行更改；反之，则更新。

​		初始时的算法复杂度是o（n^2），经过更改变为了O（n log n+l）n是节点数，l是多少条线。

### P14	数据结构

#### 24.算法处理的数据存在内存里的格式是什么

​		字符再存储的末尾为'\0'.

​		多个变量打包在一起叫数据结构。

​		 数组的缺陷：创建时就有固定大小，不能动态增加0大小，而且数组在内存中顺序存储，在中间插一个值很难。

#### 25.节点

​		“节点”，它会存一个变量（一个指针）。

​		用节点可以做链表，链表是一种灵活数据结构，能够存放很多个节点。灵活性是通过每个节点指向下个节点实现的

​	  对其进行些许操作，最高的节点叫“根节点”。“根节点”所有节点都叫“子节点”。任何子节点的指数直属上层节点“母节点”。“树”结束的地方叫“叶节点”。

### P15	阿兰**·**图灵

#### 26.简介

​		阿兰**·**马蒂森**·**图灵被称为计算机之父。

​		图灵奖是计算机领域的最高奖项。

​		提出了：如果计算机能欺骗人类相信它是人类，才算智能。

#### 27.可判定性问题

##### 		1)内容

​				是否存在一种算法，输入正式逻辑语句，输出准确的“是”或“否”答案？

##### 		2)解决方法

​				阿隆佐**·**丘奇(美)1935年首先提出解决方案，开发了一个叫做“Lambda算子”的数学表达系统，但证明了这种算法不存在。虽然其可以表示任何计算，但使用的数学技巧难以理解和使用。

​				阿兰**·**图灵提出的“图灵机”。图灵机提供简单有强大的数学计算模型，虽然用的数学不一样，但图灵机的计算能力和Lambda算子一样。

#### 28.图灵机

​	这是一台理论设备

##### 	1)配置

​			无限长的纸带(纸带可以存储符号)、一个读写头(可以读取和写入纸带上的内容)

​			一个状态变量(保存当前状态)

##### 	2)规则

​			规则根据当前状态以及读写头看到的符号，决定机器做什么，结果可能是在纸带上写入一个符号，或者改变状态，或者把读写头右移一格，或执行这些动作的组合。

​			如果当前状态是“偶数”，当前符号是1---->把状态更新为“奇数”，把读写头向右移动

​			如果当前状态是“偶数”，当前符号是0---->意味着到了字符串的结尾，在纸带上写个1，并把状态改为“停机”。

​			 如果当前状态是“奇数”，当前符号是1---->把状态更新为“偶数”，把读写头向右移动

​			 如果当前状态是“奇数”，当前符号是0---->意味着到了字符串的结尾，在纸带上写个0，并把状态改为“停机”。

​				起始状态为偶数。

##### 	3)地位

​				图灵机是强大的计算模型。

​	4)延伸

​				图灵完备：如今都在用的就是图灵完备

#### 29.停机问题

##### 	1)描述

​		给图灵机描述和输入纸袋，是否有算法可以确定机器会永远算下去还是到某一点会停机？

##### 	2)操作

​		图灵通过一个巧妙的逻辑矛盾证明了停机问题是无法解决的。

​		图灵提出：如果有一个程序，H无法判断是否会“停机”，则意味着“停机问题”无法解决。

​		有一个假想的图灵机，输入问题的描述和纸带的数据，如果输出YES则不会停机，输出NO会停机。

​		在这样一个机器前面加入一个分离器，让程序只接收一个输入，这个输入既是程序，也是输入。

​		将这个机器的输出作为输入，则会不能正确的判定停机问题

30.小知识

​		丘奇和图灵证明了计算是有极限的，并起步了可计算性理论，现在叫做“丘奇-图灵论题”。

31.图灵测试

​		智能测试的基础：如果计算机能欺骗人类相信它是人类，才算智能。

​		具体内容：非面对面，而是来回发消息，可以问任何问题而回收到答案

​		现代版：公开全自动图灵测试----->用于区分计算机和人类

### P16   软件工程

#### 32.软件工程的诞生

##### 	1)命名者

​				Margaret Hamilton

##### 	2)形成原因

​				为了写大型程序，程序员用各种工具和方法。

#### 33.面向对象编程

​	诞生原因：过多的代码，即使打包成函数依旧太多。

​	解决方法：把函数打包成层级，把相关的代码都放在一起，打包成对象。

​	面向对象编程：把函数打包成对象的思想。

​	对于非本团队的对象编程，需要文档帮助理解代码都做什么以及定义好的“程序编程接口”--简称API

​	API帮助不同程序员合作，不用知道具体细节，只要知道怎么使用就行了。

​	API控制哪些函数和数据让外部访问哪些仅供内部。

​	“面对对象”的编程语言，可以指定函数是public或private，来设置权限。

​	如果标记成prinvate----->只有同一个对象的其他函数能调用它。

​	“面向对象编程”的核心是隐藏复杂度，选择性的公布功能。因为做大型项目很有效，所以广受欢迎。

#### 34.注意

​		代码在编译前就只是文字而已。

#### 35.IDE

##### 1)介绍

​		写代码的工具里继承了很多有用的功能，帮助写代码，整理，编译和测试码，因为集成了所有的东西，因此叫集成开发环境，简称IDE。

​		IDE可以帮助开发者整理和看代码。

##### 2)调试

​		很多IDE还可以直接编译和运行代码，如果出错了，还会定位到出错代码，并提供信息，帮助解决问题，叫做调试（debug）。

​		调试很重要，大多数程序员会花70%~~80%时间调试，而不是在写代码。

##### 3)注释

​		程序员工作的另一个重要部分：给代码写文档（相当于是注释）

​		注释的唯一作用：帮助开发者理解代码。

​		好文档能帮助开发者在几个月后理解自己的代码，对其他人也很重要。

​		文档还可以提高复用性，可以直接使用别人写好的来解决问题。

#### 36.源代码管理

​		帮助团队协作的另一个重要软件，源代码管理，也叫“版本控制”。

​		像苹果之类的一些大公司会把代码放在一个中心服务器上，叫做“代码仓库”。

​		当程序员想该一段代码的时候，可以用check out .

​		修改完毕后可以把代码放回去，叫做“提交”。

​		当多次修改之后，可能会有地方起到冲突，源代码管理可以跟踪所有变化，如果发现bug,会将全部或者部分代码“回滚”到之前的稳定版，也会记录谁改了什么代码。

#### 37.测试

​		写代码和测代码密不可分，测试一般由个人或者小团队完成。

​		测试可以统称为“质量保证测试”，简称QA。严格测试软件的方方面面，模拟各种情况，看软件会不会出错，基本上就是找bug。

38.测试版本

##### 	1)alpha版本

​			一般很粗糙，错误很多，经常只在公司内部测试。

##### 	2)beat版

​			公司对外发放的接近完成的软件，向公众发放，以帮助发现问题。用户就像免费的QA团队。

### P17集成电路&摩尔定律

#### 39.零散点

​		大约1940年代~1960年代中期这段时间里计算机都由独立部件组成，叫“分立元件”。然后用不同的线连接在一起。

​		数字暴政：如果想要提升性能，就要加更多部件，这导致更多电线，更复杂。

​		晶体管虽然更小更快，但并没有解决“数字暴政”的问题，有几十万个独立元件的计算机不但难设计，而且难生产。

​		所以提出了电子部件：与其把多个独立部件用电线连起来，拼装出计算机，我们把多个部件包在一起，变成一个新的独立部件。

​		1959年Robert Noyce的仙童半导体让集成电路变成现实。仙童半导体公司用硅（硅的藏量丰富，占地壳的四分之一，且更稳定可靠）。

​		Noyce被认为是现代集成电路之父，开创了电子时代，创建了硅谷。

#### 40.PCB

​		印刷电路板

​		可以大规模生产，无需焊接或用一大堆线，它可以通过刻蚀金属线的方式，把零件连接到一起，于IC结合使用，可以大幅减少独立组件和电线，但做到相同的功能。

#### 41.光刻

##### 1)介绍

​		用光把复杂的图案印到材料上，比如半导体。

​		硅是做晶体管的绝佳材料。

##### 2)步骤

​		i)以晶圆为基础，在其上加一层薄薄的氧化层，作为保护层；

​		ii)然后加一层特殊的化学品，叫“光刻胶”，光刻胶被光照射后会变得可溶，可以用一种特殊化学药剂洗掉；

​		iii)再往其上加光掩膜，单单光刻胶本身并不是很有用，但和“光掩膜”配合使用会很强大，光掩膜就像胶片一样，要转移到晶圆上的图案。把光掩膜盖到晶圆上，用强光照射，挡住光的地方，光刻胶不会变化；

​		iv)光照到的地方，光刻胶会发生化学变化，洗掉它之后，暴露出氧化层；

​		v)用另一种化学物质--通常是一种酸，可以洗掉“氧化层”露出的部分，刻蚀到硅层（有一部分氧化层被光刻胶保护住了）；

​		vi)用另一种化学物质清洗掉光刻胶；

​		vii)硅露出来之后，想修改使其导电性更好，所以用另一种化学过程来改变它，叫“掺杂”。

​			“掺杂”通常用高温气体来做，比如磷，渗透进暴露出的硅，改变电学性质；

​		viii)仍需几轮光刻法来做晶体管；

​		ix)前面过程基本一致，先盖氧化层，再盖光刻层 ，然后用新的光刻膜，这次图案不同，在掺杂区域上方开一个缺口，光照之后，洗掉光刻胶，然后用另一种气体把一部分硅转化成另一种形式（而且不要超过之前的区域）；

​		x)再次用光刻胶和光掩膜，刻蚀出小通道；

​		xi)再用新的处理方法（叫做“金属化”），放一层薄薄的金属，比如铝或铜；

​		xii)再重复前面的步骤，用光刻胶+光掩膜，然后溶掉暴露的光刻胶，暴露的金属；

​		每个区域的掺杂方式不同，这叫做“**双极型晶体管**”。

##### 3)注意

​		光刻法用很多化学品，每种都有特定的用途

​		光刻还可以用在制作其他电子元件，比如电阻和电容，都在一片硅上。

​		现实中的光刻法一次会做上百万个细节。

​		可以把光掩模聚焦到极小的区域，制作出非常精细的细节。

#### 42.注意点

​		芯片的核心都是一小片IC。

​		晶体管更小密度更高还有一些好处：晶体管越小，要移动的电荷就越少，能更快切换状态，耗电更少。电路更紧凑，还意味着信号延迟更低，导致时钟速度更快。

​		1970年代开始，超大规模集成（VLSI）软件用来自动生成芯片设计。

#### 43.摩尔定律

​		1965年，戈登**·**摩尔看到趋势：每两年左右，得益于材料和制造技术的发展，同样的大小，能塞进两倍数量的晶体管。

#### 44.晶体管进一步做小所面临的问题

1)用光掩膜把图案弄到晶圆体上因为光的波长，精度已达极限，所以科学家在研制波长更短的光源，投射更小的形状；

2)当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，这叫做：量子隧穿效应。

### P18	操作系统

#### 45.早期电脑使用

​		1940~1950年代的电脑，每次只能运行一个程序，程序员在打孔卡纸上写程序，然后拿到一个计算机房间，交给操作员，等计算机空下的时侯，操作员将程序放入，然后运行，输出结果，停机。

#### 46.操作系统

##### 1)诞生的原因

​		计算机的速度越来越快，很快放程序的时间比程序运行的时间还长，需要一种让计算机自动运作的东西。

##### 2)介绍

​		简称OS，其实也是程序，但它有操作硬件的特殊权限，可以运行和管理其他程序。

​		操作系统一般是开机第一个启动的程序，其他所有的程序都有操作系统启动。

​		操作系统开始于1950年代，第一个操作系统加强了程序加载方式（之前只能一次给一个程序，现在可以一次多个，当计算机运行完成一个程序，会自动运行下一个程序，叫做“批处理”）。

##### 3)具体

​		操作系统提供API来抽象硬件，叫“设备驱动程序”。

​		是程序员可以用标准化机制和数额u输出硬件（I/O）交互。

##### 4)发展

​	五十年代后期，英国曼彻斯特大学开始研发世界上第一台超级计算机--Atlas

###### 	i)多任务处理

​	为了最大限度地利用它，他们的解决方案是一个1962年完成的程序---Atlas  Supervisor ，不仅可以自动加载程序，还能在单个CPU上同时运行几个程序，通过调度完成。

​		如：执行print时，打印机比CPU慢，Atlas会把程序休眠，运行另一个程序，直到打印机反馈打印已完成，Atlas会把程序标成可继续运行，之后在某时刻安排给CPU运行。

​		操作系统这种能力叫“多任务处理”。

​		为了切换程序时不丢失数据，给每个程序分配专属内存块。

###### 	ii)虚拟内存

​		数据存在一堆不连续的内存块里，为了隐藏这种复杂性，操作系统会把内存地址进行“虚拟化”，叫做“虚拟内存”。程序可以假定内存总是从地址0开始，而实际物理位置被操作系统隐藏和抽象了。操作系统会自动处理虚拟内存和物理内存之间的映射。

​		这种机制是程序的内存大小可以灵活增减，叫“动态内存分配”。它简化了一切，为操作系统同时运行多个程序提供了极大的灵活性。

###### 	iii)内存保护

​		这样的机制的另一个好处是：如果一个程序出错，开始写入乱七八糟的数据它只会捣乱自己的内存，不会对其他程序造成影响，叫做“内存保护”。对于防止恶意软件（如病毒）也很有用。

###### iv)分时操作系统

​		操作系统不但要处理多个程序，还要处理多个用户，为确保其中一人不会占满计算机资源，开发了分时操作系统-----每个用户中能使用一小部分处理器、内存等。

​		早期最具影响力的是Multics（多任务信息与计算机系统），也是第一个从设计时就考虑安全的操作系统

##### 5)组成

​	i)内核：如内存管理，多任务和输入/输出处理；

​	ii)有用的工具，但不是内核的一部分（比如程序和运行库）；

#### 47.注意点

​	与计算机连着的其他设备，统称为“外部设备”。

​	Unix是1970~80年代最流行的操作系统之一。

​	1980年代早期计算机的价格降到普通人买得起，这些叫做“个人电脑”或“家庭电脑”。

​	蓝屏代表程序崩溃的非常严重，把系统也崩溃了。

### P19	内存&储存介质

#### 48.零散点

​		一般来说，电脑内存是“非永久性”。所以内存叫“易失性”存储器。

​		写入存储器的数据，比如硬盘，数据会一直存在，直到覆盖或删除，断电也不会丢失，存储器是“非易失性”的。

​		UNIVAC是最早进行商业销售的电脑之一。

#### 49.存储介质的发展

##### 	1)	打孔卡纸

​		最早的存储介质是打孔卡纸以及纸卡的亲戚---打孔纸带

​		优点：不用电而且便宜耐用

​		缺点：读取慢，只能写入一次

##### 	2)	延迟线存储器

###### 		i)原理

​			一根灌满水银的管子，一端放扬声器，另一端放麦克风，扬声器发出脉冲，会产生压力波压力波需要时间传播到另一端的麦克风，麦克风将压力波转换回电信号，我们可以用压力波的传播延迟来存储数据，可以将有无压力波作为区分和的区别。

​			如果再加一个电路，将麦克风与扬声器连接起来，再加一个放大器（Amplifier）来弥补信号衰弱，就可以做成一个存储数据的循环，

​			信号沿电线传播几乎是瞬时的，所以在任何时间节点都只显示1bit数据，但管子中可以存储多个位（bit）.

​			使用延迟先存储器的EDVAC是最早的“存储程序计算机”之一。

###### 		ii)缺点

​			每个时刻只能读取一位(bit)数据，如果要等待一个122的数据，得等待它从循环中出来，所以又叫“顺序存储器”或“循环存储器”。

###### 		iii)目标

​			但我们想要的是随机存储器，可以随时访问任何位置

​			增加内存密度也是一个挑战把压力波变得更紧密，意味着更容易混在一起，就出现了其他的类型的“延迟线存储器”，如“磁致伸缩延迟存储器”。

###### 		iv)磁致伸缩延迟存储器	

###### 					原理：用金属线的振动来表示数据，通过把线卷成线圈，1英尺X1英尺的面积能存储大概1000位（bit）

###### 		v)过时

​				延迟线存储器在1950年代中期就基本过时了，因为出现了新技术，性能，可靠性和成本都更好

##### 	3)	磁芯存储器

###### 		i)原理

​			像用了甜甜圈的小型磁圈，如果给磁芯绕上电线并施加电流，可以将磁化在一个方向，如果关掉电流，磁芯保持磁化，如果沿反向施加电流，磁化的方向（极性）会翻转，这样就可以存储0和1。

​			如果只存一位不够用，所以把小甜甜圈排列成网格，有的电线负责选行和列，也有的贯穿每个磁芯，用于读写一位(bit)。

![image-20211205120003299](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211205120003299.png)

###### 		ii)优点

​			可以随时访问任何一位(bit)

###### 		iii)缺点

​			价格昂贵

##### 	4)	磁带

###### 		i)原理

​			磁带是纤薄柔软的一长条磁性带子，卷在轴上，磁带可以在“磁带驱动器”内前后移动，里面有个“写头”绕了电线，电流通过产生磁场，导致磁带的一小部分被磁化，电流方向决定了极性，代表1和0。

​			还有一个“读头”可以非破坏性的检测极性。

​			磁带每英寸可存128位数据。

###### 		ii)使用

​			虽然磁带驱动器很贵，但是磁带又便宜又小，因此磁带至今仍用于存档。

###### 		iii)缺点

​			访问速度----->磁带是连续的，比须倒带或快进到达特定位置

​		iv)延申

​			1950~1960年代，有个类似的技术是“磁鼓存储器”，有金属圆筒，盖满了磁性材料以记录数据，滚筒会持续旋转，周围有数十个个读取头，等滚筒滚到正确的位置，读写头会读或写一位(bit)数据。

​			为了尽可能缩短延迟，鼓轮每分钟上千转

##### 	5)	硬盘

###### 		i)原理

​			磁盘表面有磁性，读取头和写入头可以处理上面的1和0

###### 		ii)好处

​			薄，可以叠在一起

​	6)软盘

​		便携

​	7)光学存储器

​		后来成为CD(光盘)和DVD

​		原理：光盘表面有很多小坑，造成了光的不同反射，光学传感器会捕获到，并解码为0和1

​	8)SSD

​		固态硬盘，里面是集成电路。

​		访问时间为1/1000秒，很快，但是仍比RAM慢，所以现代计算机依旧使用存储层次结构

#### 50.寻道时间

​		访问任意数据的时间的平均值

### P20	文件系统

#### 51.文件格式

​		随意排列文件数据完全没问题，但是按格式排会更好。

​		程序员可以发明自己的格式，但是最好用现成标准，比如JPEG和MP3

##### 	1)文本文件

​		最简单的是文本文件，也叫TXT文件，里面包含二进制，转化为十进制，再用ASCII解码

##### 	2)音频文件

​		波形文件（Wave），也叫WAV，存储音频数据。

##### 	3)图片文件

​		位图（Bitmap）,后缀	**.bmp**,它存图片。

​		计算机上，图片由很多个叫“像素”的方块组成，每个像素由三种颜色组成：红，绿，蓝。这三种颜色叫做“加色三原色”，混在一起可以创造其他颜色

​		像WAV文件一样，BMP文件开头也是元数据，有图片宽度、图片高度、颜色深度

##### 	4)总述

​			文件在底层全是一样的，：一长串二进制

#### 52.元数据

​		定义：关于数据的数据。

​		在正确读取之前，需要知道一些信息。

​		元数据存在文件开头，在实际数据前面，因此也叫文件头。

#### 53.计算机存储数据

##### 	1)早期

​		很早期的时候，计算机只做一件事，整个存储器就像一整个文件，数据从头到尾，直到存满为止

##### 	2)发展

​		随着计算能力和存储容量的提高，存多个文件变得非常有用。

​		最简单的方法是把文件连续存储，但存储器没有文件的概念，只是存储大量位。

​		所以为了存多个文件，需要一个特殊文件记录其他文件的位置，这个文件一般在最开头，方便找。

​		这个文件里存着其他文件的所有名字，格式是文件名+“.”+"扩展名"，扩展名帮助获知文件类型，还存着文件的元数据，比如创建时间、最后修改时间，文件所有者是谁、是否能读/写或读写都行，而且，记录着文件起始位置和长度。

​		如果要添加文件，删除文件，更改文件名等必须更新该文件。

​		文件系统专门负责管理文件，上面的例子叫做“平面文件系统”。

​		文件夹套文件夹的存储方式是“分层文件系统”。

##### 	3)处理弊处

​			防止文件在增加数据时覆盖其他文件数据，现代文件系统会做两件事：

​					i)把空间划分成一块块的，导致一些“预留空间”可以方便改动，同时也方便管理，但要记录文件在哪个块里。

​					ii)拆分文件，放在多个块里，但记录时块会记录多个

​						文件存放在多个块里，不仅被隔开，而且顺序是乱的，叫做碎片。碎片是增/删/改文件导致的，不可避免。

​						现代解决碎片多且杂的方法是碎片整理---->计算机会把数据来回移动排列成正确的顺序

##### 	4)分层文件系统

​			相比较平面文件系统，最大的变换是那个特殊文件不仅要指向文件，还要指向目录。

​			需要额外的元数据，来区分文件和目录。

​			这个特殊文件在最顶层，所以叫做“根目录”，其他文件和文件夹都在根目录之下。

​			移动文件变得简单，只需要在一个文件里删除一条记录，另一个添加一条记录。

​	5)评价

​			文件系统使我们不必关心文件在磁带或磁盘的具体位置，整理和访问文件更加方便。

## （三）P21--P30

云里云外博客地址：https://www.yunliyunwai.cn/blog/detail/70410abd354d4f875354f70ffb588b4a

### P21	压缩

#### 1.压缩

​	1)产生原因

​			一些格式简单的文件效率不高，人们希望文件能小一点，这样可以存放大量文件，传输也会快一些。

​	2)实质

​			把数据占用的空间压的更小，用更少的位来表示数据。

​	3)解决方法

​			下面两种方法通常会组合使用

​			i)减少重复信息----->游程编码

​					适用于经常出现相同值的文件。

​					将相同的文件重复出现时，在相同文件的第一个前加上连续的出现次数，但为了防止搞混，其他文件也需添加出现次数，即使只出现连续的一次。

​			ii)用更紧凑的方式表示数据块(简写为DFTBA)----->字典编码

​					需要一个词典来存储“代码”与“数据”间的对应关系 

​					一种方法叫做“霍夫曼树”，将所有块的频率计算出来，然后对其进行排序，每次选出最低的两个，合并成一个新的块，然后直到全部合成，就像下面的那种，再将待压缩文件中的块用后面的词典中各个块代表的新生成的编码替换文件中的部分，最后见替换后的部分与词典放在一起，就压缩完毕了。

​	![image-20211206142125217](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211206142125217.png)

#### 2.无损压缩

​		代表有游程编码和字典编码

​		没有丢失任何数据，解压缩后，数据和压缩前完全一致。

#### 3.有损压缩

​		删去一些人类不能读懂或听懂的东西---->感知编码

​			感知编码依赖于人类的感知模型，模型来自“心理物理学”领域。

​		例如对音乐压缩--->用不同精度编码不同频道，将超声波之类人听不见的声音删去

​				例如打电话就使用了压缩音频技术，为了更多人同时打电话，如果网速慢了，会删得更多

​		图片有损压缩---->利用人们对颜色的细微变化不灵敏

​			JPEG利用这个点，将图片变为8x8的像素块，然后删掉大量高频率空间数据

​		视频压缩

​			视频只是一长串连续图片，所以图片的很多方面也适用于视频，帧与帧之间也有像素，视频可以不用每一帧都存储完全不变的东西的像素，可以只存变了的部分，这叫做“时间余”。这比存所有的像素更有效率，利用了帧和帧之间的相似性。

​			更高级的压缩--->找出帧与帧之间相似的补丁，然后利用简单的效果实现，比如移动和旋转。

​			当压缩太严重时会出错，没有足够空间更新补丁内的像素，但即使补丁错误，视频播放器依旧会播放

### P22	命令行界面

#### 4.交互的定义

​		许多“输入输出设备”让人与计算机交互，并在人与机器之间提供了界面，有整个学科研究这个，叫“人机交互”。

​		交互式就是人和计算机之间来回沟通。

#### 5.命令方式的发展

​		早期机械计算设备用齿轮、旋钮和开关等机械结构来输入输出，输出打印到纸上。

​		1950年代使用打孔卡纸和磁带，但当时的特点是尽可能迁就机器，对人类好不好用是其次。

​		1950年代晚期，小型计算机变得的足够便宜，且大型计算机变得更快，能同时支持多个程序和多个用户。进行交互式操作时，计算机需要某种方式来获得用户输入，使用当时已经存在的数据录入机制---->键盘。

​		早期计算机用一种特殊的打字机，是专门用来发电报的，叫  电传打字机。这些打字机是强化过的，可以用电报线发送和接收文本。

​		电传交互界面在1960~1970很常见。

​		随着屏幕的发展，工程师将电子打字机的协议用到了屏幕上，出现了终端。

#### 6.键盘

​		键盘在1874年被研制出来，之后取得商业成功，常见的布局是QWERTY，还有其他种类的存在。

​		速打的出现是“十指打字”以及“十指盲打”的流行而出现的。

#### 7.命令行界面

​		输入一个命令，按回车，然后计算机会输回来计算机与用户来回“对话”。-->1980年前主要的人机交互方式。

### P23	屏幕&2D图形显示

#### 8.图形界面的发展

##### 1)早期屏幕的经典用途

​		跟踪程序的运行情况，屏幕很少用于输出计算结果，结果一般都打印到纸上。

##### 2)阴极管射线

###### 	i)出现

​		几十年间出现了很多显示技术，但最早最有影响力的是阴极射线管（CRT）。

###### 	ii)原理

​		把电子发射到有磷光体涂层的屏幕上，电子撞击图层的时候会发光几分之一秒，电子的路径可由磁场控制。

​	iii)绘图方法

​		一：矢量扫描---->引导电子束描绘出形状

​			虽然发光时间短，但只要重复的足够快，就可以得到清晰的图像，

​		二：光栅扫描---->按固定路径一行行来，从上到下，从左到右，不断重复。只在特定的点打开电子束，以此绘制图形。

​			甚至可以用很多小线段绘制形状甚至文字， 显示技术的发展使得屏幕上出现清晰的点--->像素。

3)早期计算机屏幕

​	早期的计算机屏幕不用像素，不是因为技术做不到，而是因为像素占太多内存。

​	早期图形的发展是受到内存的制约。

​	早期计算机不存大量像素值，而是存符号，80x25个符号最典型。

​	故计算机需要额外的硬件来从内存读取字符，转换成光栅图形，这样才能显示在屏幕上。

​	这个硬件叫做“字符生成器”，基本算是第一代显卡。它的内部有一块只读存储器，简称ROM，存着每个字符的图形，叫“点阵图形”。

​	为了显示，“字符生成器”会访问内存中的一块特殊区域，这块区域转为图形保留，叫屏幕缓存区。

​	程序想显示文字时，修改这块区域里的值就行。用的内存少，但意味着只能画字符到屏幕上。

​	字符生成器是一种省内存的技巧，但没办法绘制任意形状。

​	为了绘制任意形状，同时不吃掉所有内存，计算机科学家用CRT上的“矢量模式”。---->概念：所有东西都由线组成。

4)Sketchpad

​	一个交互式图形界面，用途是计算机辅助设计(CAD)---->被广泛认为是第一个完整的图形程序

​	为了与图形界面交互，使用当时发明不久的输入设备---->光笔，就是一个有线连着电脑的触控笔，笔尖用光传感器，可以检测到显示器刷新，通过判断时间，电脑可以知道笔的位置。

​	光笔和各种按钮使用户可以画线和各种其他简单形状，甚至可以让线条完美平行，长度相等，完美垂直90度，甚至动态缩放。

​	用户还可以保存设计结果，方便以后再次使用，甚至和其他人分享。

5)使用像素的计算机

​	最早用真正像素的计算机和显示器出现于1960年代末，内存中的位对应屏幕上的像素，这叫位图显示，可以绘制任意形状的东西。

​	计算机把像素数据存在内存中的一个特殊区域，叫“帧缓冲区”。早期时，这些数据存在内存里，后来存在高速视频内存里，简称VRAM。VRAM在显卡上，这样访问更快。

​	因为早期显示器不能显示白色，所以其实更像绿色或橙色。

​	在像素界面画更复杂的图形，比如矩形，那么需要四个值（起始x,y坐标，长度、宽度）以及颜色。

​	位图的灵活性，为交互式开启了全新的可能，但它的高昂成本持续了十几年。

### P24	冷战和消费

#### 9.历史

​	1950年，Univac1---第一台取得商业成功的电脑。

​	计算机增强的是人类智力。

​	范内瓦·布什1945年发表了一篇文章，描述了一种假想计算设备叫Menex，用这个装置可以存自己所有的书、其他资料以及和别人沟通，而且数据是按照格式存储，所以可以快速查询，有很大灵活性，可以辅助我们的记忆。他还预测了维基百科的出现。

​	苏联计算机科技比西方落后几年，1950年研制出了第一台可编程计算机，但在太空方面优先于美国，1957年把第一个卫星送上太空轨道，并于1961年苏联宇航员尤里·加加林第一个进入太空。使美国提出了登月计划，并推动了计算机的发展。

​	美国为了登月计划，大量资金投资NASA，NASA用这笔资金资助各种科学研究，花费最大的是阿波罗计划，雇佣了40万人左右，而且有2万多家大学和公司参与。NASA需要电脑计算复杂的轨道来引导太空船，于是制造了“阿波罗导航计算机”，制造的三个要求：计算机要快、计算机要又轻又小、要超级可靠。

​	阿波罗计算机的制造真空管和晶体管都不符合其要求，就使用了集成电路。

​	人们常把集成电路的发展归功于阿波罗登月计划，但实际上是军事大大推进了集成电路的发展，特别是洲际导弹和核弹，使集成电路大规模生产。

​	同时，美国建造强大计算机时，也进一步推进了集成电路。

​	起初，美国半导体行业最高利润政府合同起步，因此忽略了消费者市场，于是日本半导体行业在1950年和1960年代靠低利润占领了消费者市场，并且采用多种方法降低成本。

​	因为在半导体比不过日本，英特尔开始研发处理器。

​	手持计算机的发展使得集成电路进一步发展。

​	计算机的发展是靠政府和消费者推动的。

### P25	个人计算机革命

10.零散点

​		单芯片CPU的出现以及集成电路的进步（提供了低成本的固态存储器），是个人使用计算机得以实现。

####  11.解释器

​		把代码转化成可执行机器码的程序。

​		与编译器不同点，编译器是在提前转换，而解释器则是运行时转换。

​		1977年出现了三款开箱即用的电脑，而且自带BASIC解释器，使得计算机与家用电器之间的界限变得模糊，走进了普通消费者当中。市场上也出现了不少针对计算机的游戏、计算机等等。1979年出现了第一个电子表格程序，主要面对的是普通消费者，这也让计算机更加广泛地出现在家庭、小公司以及学校当中。

​		苹果1984年发布Macintosh---->一台突破性、价格适中的一体式计算机，用的不是命令行界面，而是图形界面

### P26	用户图形界面GUI

​	现代图形界面的先驱可以说是道格拉斯·恩格尔巴特

​	为了让计算机易于使用，借助于人们熟知的概念，是人们无需培训即可很快明白如何使用。------>把2D屏作为桌面。

​	用户可以打开多个程序，每个程序都在一个框里，叫“窗口”。

​	用窗口、图标、菜单和指针来设计桌面，因此叫“WIMP界面”。

​	施乐公司首先使用了“剪切”“复制”“粘贴”等术语。

​	“所见即所得”是指打印下的内容与计算机上完全一致。

### P27	3D图形

#### 12.3D图处理

##### 	1)介绍

​		3D使用xyz三维坐标系建立，利用图形算法把3D坐标“拍平”显示到2D屏幕上。----->3D投影

​		在3D坐标全部转化为2D之后，利用画2D线段的函数来连接这些点。------------------>线框渲染-------->一般用三角形做基本形状

​		只有线框渲染显然不够，要填充图形，填充图形的经典算法是--------------------------->扫描线渲染

##### 	2)使用

​		立方体的各个边，在投影中相互平行----------------->正交投影

​		立方体的各个边，平行线段在远处收敛于一点----->透视投射

​		一堆多边形的集合叫网格。

##### 	3)注意

​		游戏设计者要平衡角色的真实度和多边形数量，如果数量太多，帧率会降到肉眼可感知，用户会觉得卡，所以有算法来简化网格。

​		3D游戏中有个优化叫做背面剔除比如游戏角色的头部或地面，只能看见朝外面的一面，所以为了节省处理时间，会忽略多边形背面，减少一半的多边形面数。

##### 	4)扫描线渲染

​		填满两个相交点之间的像素

​		填充的速度叫fillrate（填充速率）。

##### 	5)锯齿和抗锯齿

​		如果就这样填完的话，这样的三角形是比较丑的，因为边缘全是锯齿，当像素较小时就不会太过于明显。

​		一种减轻锯齿的方法叫做抗锯齿（Antialiasing），会判断多边形切过像素的程度，来调整颜色。如果像素在多边形内部就直接涂色，如果多边形划过像素，颜色就会浅一些。抗锯齿被广泛应用，比如字体和图标。

##### 	6)遮挡

​		在3D场景中，多边形到处都是，但只有一部分能看见，因为其他的被遮挡住了，叫做“遮挡”。

​		最简单的处理方法使用排序算法，从远到近排列，然后从远到近渲染，这叫做画家算法。

​		深度缓冲：先将每个像素到前面的距离为无穷大，然后再将每个多边形扫描，但是不上色，只记录该像素块的最小值，因为没有对多边形排序，所以不会覆盖前面的，缓存区结束之后，会和“扫描线”算法的改进高级版配合使用，不仅可以勘测到线的交叉点，还可以知道某像素是否在最终场景中可见。如果不可见，扫描算法会跳过那个部分，但是当有一部分中多个多边形距离相等时，该填那个多边形的颜色？

##### 		7)灯光处理

​				明暗处理--->因为是3D场景，物体表面应该有明暗变化

​				多边形面对的方向叫做“表面法向”。可以用一个垂直于表面的小箭头来显示这个方向。

​				平面着色（最基本的照明算法）：距离近的且能把光反射到所视处的地方亮一点，越远或越偏的的地方越暗。---->缺点：使多边形边界十分明显，看起来不光滑。

​				更高端的着色方法（比如高洛德着色和冯氏着色），不止用一种颜色给整个多边形上色，而是以巧妙的方式改变颜色。

##### 		8)纹理

​				在图形学中指外观，而不是手感。

​				最简单的算法是  纹理映射  ，在用扫描线算法填充的时候可以看看内存内的纹理图像，决定像素用什么颜色，为了做到这点，要把多边形坐标和纹理坐标对应起来

##### 		9)GPU

​				加速渲染的方法：为某种特定运算做专门的硬件来加快速度；把3D场景分解成多个小部分，然后并行渲染，而不是按顺序渲染。

​				计算机工程师为此专门设计了还专门处理这部分的处理器，叫做GPU“图形处理单元”。

​				GPU在显卡上，周围有专门的RAM，所有的网格和纹理都在里面，让GPU的多个核心可以高速访问

### P28	计算机网络

#### 13.时延

​		时延是指传播一条信息所需的时间。

#### 14.计算机网络的发展

##### 1)发展

​		第一个计算机网络出现在1950~1960年代，通常在公司或研究室内部使用，为了方便信息交换，还可以共享物理资源。

##### 2)局域网

​		计算机近距离构成的小型网络叫局域网，简称LAN。

​		局域网最成功的是以太网。以太网最简单的形式是一条以太网电线连接数台计算机。

​		为了解决当传送信息时不知道是传给局域网内的哪一台电脑这个问题，以太网需要每一台计算机有唯一的媒体访问控制地址，简称为MAC地址。

​		多台电脑共享一个传输媒介，这种方法叫“载波侦听多路访问”简称“CSMA”。

​		载体指运输数据的共享媒介，以太网的“载体”是铜线，WiFi的“载体”是传播无线电波的空气。

​		 由于许多计算机同时侦听载体，所以又叫“侦听”和“多路访问”，而载体传输数据的速度叫“带宽”。

​		当两台或两台以上的计算机同时传输数据的时候，就会形成冲突，造成数据混乱；当无法传输时，若隔段时间上传，依旧会有可能造成冲突。对于这种问题，以太网的解决方法：i.当产生冲突的时候，以太网会是造成冲突的每个计算机都进入1+随机时间（秒）的“沉睡”，当某个计算机“醒来”看见载体是空的，就将自己要上传的信息上传，但当“醒来”时看见的载体是被占据的，就会等待上一个计算机传输完毕。（有用，但不能完全解决问题）

​		还需使用另一个技巧，当等待上一个计算机传输完毕之后，再次发生了冲突的时候，本次的随机沉睡时间变为了2+随机时间（秒），之后以2的次数递增。这种方法叫做“指数退避”。---->以太网和WiFi以及其他很多传输协议也用。

​		一根网线串联整个大区域显然不太可能，所以需减少同一载体中设备的数量，载体和其中的设备总称“冲突域”。

​		为了减少冲突。我们可以用交换机把它拆分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络之间传数据。

##### 3)路由

​		连接两台相隔遥远的计算机或网路，最简单的方法是分配一条专用的通信线路。

​		电路交换：把电路连接到正确目的地。

##### 4)报文交换

​		不使用一条线来连接，而是通过多个中转站来完成的。

​		好处：可以用不同的路由，使通信更可靠更容错。

​		跳数：信息沿着路由跳转的次数。----->可以分辨出路由的问题。当条数过大时，路由就会知道出了问题了，这叫做“跳数限制”。

​		缺点：当文件过大时会堵塞网路-------->解决方法：将大报文分成很多小块，叫“数据包”。这种方法叫做“分组交换”。

##### 5)IP

​		报文的具体格式由“互联网协议”定义，简称IP，这个标准创建于1970年代。

​		同一个文件的数据包可能经过不同的路线，导致到达顺序不一样，对一些软件来说有大问题。

​		再IP之上还有其他的协议，如CTP/IP---->可以解决乱序问题。

##### 6)阻塞控制

​		路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠，这叫“阻塞控制”。

### P29	互联网

#### 15.数据传输过程

​	计算机为了获取内容，首先连接上局域网（叫LAN），局域网再连接到广域网（叫WAN），而WAN的路由器一般属于你的“互联网服务提供商”，简称ISP。

​	广域网里，线连接到一个区域性路由器，这路由器可能覆盖一个街区，在连接到一个更大的WAM，可能再调几次，但最终到达互联网主干。

​	互联网主干由一群超大型。带宽超高路由器组成

#### 16.协议

##### 1)IP

​		最底层的协议

​		IP负责把数据包送到正确的计算机

##### 2)UDP

​		最简单、最常见的叫“用户数据协议”，简称UDP。头部存在数据里面。

​		UDP头部包含有端口号（当应用需要联网时，会向操作系统申请一个端口号）（UDP使数据包只会给端口号相同的程序），“校验和”（用于检查数据是否正确）。

​		负责把数据报送到正确的程序。

​		但UDP不提供数据修复或数据重发的机制，也不能知道数据是否已到达目的地。

##### 3)TCP

​		要求所有数据全部必须到达，用“传输控制协议”。头部存在数据里面。这个组合叫TCP/IP（同时使用TCP和IP两个协议）

​		与UDP类似，TCP头部也有“端口号”和“校验码”。

​		高级功能：i.TCP数据包有序号；

​						  ii.TCP要求接收方的电脑收到数据包并且“校验码”检查无误后（数据没有损坏），给发送方发一个确认码，代表收到了。确认码简称ACK。

​		如果收到相同的数据报，就会删除。

​		根据确认码的成功率和回来时间，可以推测网络的拥堵情况，TCP可以根据这个信息，调整发包数量解决拥堵问题。

​		缺点：”确认码“数据包把数量翻了一倍，但并未多加信息。

#### 17.域名

​		计算机访问一个网站需要两个东西：IP地址和端口号。互联网有个特殊服务，负责把域名和IP地址一 一对应，叫”域名系统“，简称DNS.

​		当在浏览器内输入域名，浏览器会到DNS服务器内，查找对应的IP地址（一般DNS服务器由互联网供应商提供），查找到的话，浏览器会向这个IP地址发TCP请求，如果没有的话，就会出现DNS错误。

​		为了更好地管理大量域名，DNS并非是一个超级长的列表，而是存成如下图的树状结构。

​		![image-20211209113549636](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211209113549636.png)

#### 18.开放式系统互连通信参考模型

![image-20211209114418313](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211209114418313.png)

​		每一层处理各自的问题。

### P30	万维网

#### 19.万维网介绍

​	1)万维网的基本单位是单个页面

​	2)页面有内容，也有去往其他页面的链接，这些链接叫“超链接”，也叫超文本

​	3)每个网页都有唯一的地址，这个地址叫“统一资源定位器”，简称URL

​	在访问网站时，向服务器申请出这个域名的IP地址（DNS查找），然后再由电脑上的浏览器打开一个TCP连接到这个IP地址，这个地址运行着“网络服务器”（网络服务器的标准端口是80端口）。此时，计算机连接上了服务器，然后向服务器请求“course”这个页面。这里会用到“超文本传输协议”（HTTP）。HTTP的第一个标准,HTTP0.9,创建于1991年，只有一个指令，“GET”指令。在之后的版本当中，HTTP添加了状态码，状态码放在请求前面。

​	状态码400~~499代表客户端出错，404是网页不存在。

​	如果只有纯文本，无法表示什么是链接，什么不是链接，所以开发了一种标记方法---->超文本标记语言（HTML），创建于1990年。

​	我们可以用< a >标签来做超链接，它有一个href属性，说明链接指向哪里，当点击链接的时候就会进入到那个网页中，用< /a >结束。

​	网页浏览器可以和网页服务器沟通，浏览器不仅获取网页和媒体，获取后还负责显示。

​	第一个浏览器和服务器是1990年编写而成的，同时建立了几个最基本的网络标准。URL，HTML和HTTP。于1991年发布出去。

​	万维网有开放标准，大家都可以开发新服务器和新浏览器。

​	为了满足人们不知道域名还想查找文件的需求，起初是维护一个目录，连接到其它网站。

​	由于信息量的增加，人工编辑变得困难，所以开发了搜索引擎。

​	长得最像现代的搜索引擎是JumpStation,创建于1993年，有三个部分：爬虫（一个跟着链接到处跑的软件）、不断扩张的索引（访问过的网页上，出现过哪些词）、查询索引的搜索算法，

​	避免有人通过重复加单一名字引起人们的注意，谷歌研发出的新算法：与其信任网页上的内容，搜索引擎会看其它网站是否有链接到这个网站上。这些链接数量就代表了网站质量。

网络中立性：应该平等对待所有数据包，不论这个数据包是我的邮件，或者是你在看视频，速度和优先级应该是一致的。

​	节流：给更少的带宽和更低优先级。

## （四）P31-P40

云里云外博客地址：

### P31	计算机安全

#### 1.属性

​	保密性是指只有有权限的人才能读取计算机系统和数据。

​	完整性是只有有权限的人才能使用和修改系统和数据。

​	可用性是有权限的人应该随时访问系统数据的人。

#### 2.威胁攻击模型

​	拒绝服务攻击（DDOS）就是黑客发大量的假请求到服务器，让网站很慢或者挂掉。

​	“威胁攻击模型”，即安全专家从抽象层面想像“敌人”可能是谁，模型会对攻击者有个大致的描述，能力如何，目标可能是什么，可能用什么手段，攻击手段又叫矢量攻击。

​	在给定的模型下，安全架构师提供解决方法，保持系统安全。

#### 3.安全使用与防护

​	安全问题可以分为两类：你是谁？你要访问什么？

​	为了区分使用者，要使用身份验证。

​	身份验证有三种，各有利弊：

​			a.你知道什么----->基于某个只有用户和计算机知道的东西

​			b.你有什么 -------->基于用户有特定物体

​			c.你是什么--------->是基于你把特征展示给计算机进行验证

​	黑客的攻击方法之一   暴力攻击：试遍一切可能。

​	“双因素”或“多因素”认证：使用以上三种中的多种进行保护账号。

#### 4.访问控制

​	访问控制：可以通过“权限”或者“访问控制列表”来实现。其中描述了用户对每个文件，文件夹和程序的访问控制。

​	分等级权限的话，用户不能够越级读取信息，用户不能写下（只允许修改本等级的文件）。--->不能向上读，不能向下写。

#### 5.安全内核

​	系统安全的圣杯之一是“安全内核”，或“可信计算机基础”：一组尽可能少的操作系统软件。

​	构建安全内核的挑战在于决定内核应该有什么，代码越少越好。

​	审核安全内核最好的手段是“独立安全监察和质量验证”：让一群安全行业内的软件开发者来审计代码。

​	优秀的开发者应当即晃荡程序被攻破的时候，如何限制损害，控制损害的最大程度，而且不让它危害到计算机上的其他东西，这叫做“隔离”。

### P32	黑客&攻击

#### 6.黑客

​	黑客可以分为白帽和黑帽，白帽是会去检查系统的漏洞，会被大公司或者政府去做安全评估，黑帽窃取、利用和销售计算机漏洞和数据。有的黑客叫做“黑客行动社会主义者”，通过黑客手段影响社会达到政治目的。

#### 7.黑客的攻击方式

​	a.黑客最常见的入侵方式不是通过技术，而是通过欺骗他人。这叫做“社会工程学”，欺骗别人让人泄密信息,或者让别人配置电脑系统，变得易于攻击，其中最常见的是网络钓鱼。

​	b.另一种方式叫做“假托”。攻击者给某个公司打电话，假装是IT部门的人。以上都不行的时候。

就会使用其他的方法，比如:

​	c.暴力破解（尝试所有可能的密码，直到进入系统）

​	d.NAND镜像（如果能物理接触到电脑可以往内存上接几根线，复制整个内存，复制之后，暴力尝试密码，直到设备让你等待，这时只要把复制的内容覆盖掉内存，本质上等于重置了内存，既不用等待，可以继续尝试密码了）

​	e.漏洞利用（通过互联网，利用系统漏洞，来获得某些能力或访问权限）

​	f.代码注入----->最常用于攻击用数据库的网站。破解方法是把“SQL”命令输入到用户名里，可以做很多事情，比如制造混乱或者黑客获取到自己想获取的信息。

#### 8.漏洞利用

​	a.缓冲区溢出

​		缓冲区是指预留的一块内存空间

​		当在登录界面输入用户名和密码的时候，缓冲区会在幕后将你输入的值存入，但它可能会溢出缓存区，有时会让系统崩溃。攻击者会巧妙利用这个漏洞，注入一些有意义的新值，就相当于拥有了可以任意修改内存的能力，黑客可以绕过登录之类的东西，甚至会使用那个程序进行挟持整个系统。

​		解决方法：最简单的是在复制之前先检查一下长度----->“边界检查”。现代的编程语言一般都自带边界检查，程序也会随机存放变量在内存中的位置，似的更容易让程序崩溃而不是获得访问权限。

​						程序也可以在缓存区之后留下一些不用的空间，然后跟踪里面的值，看是否发生变化。那些不用的空间叫做“金丝雀”。

#### 9.数据库

​	用一种流行的数据库API----->“结构化查询语言”，也叫SQL。

​	当用户在网站上输入账号和密码之后，会将账号和密码发送到网站的数据库当中，数据库会直接查找对应用户名的信息。

​	应对黑客的方法：不允许输入一些特殊字符或者是分号，有的服务器则是会清除。

#### 10.零日漏洞

​	软件制造者不知道软件有新漏洞被发现了的这个漏洞叫“零日漏洞”。

#### 11.攻击电脑

​	保持系统更新非常重要，很多更新都是安全性补丁，若果足够多的电脑电脑有漏洞，让恶意程序可以让电脑间互相传播，叫做“蠕虫”。当黑客搞到大量电脑的时候，就会搞成“僵尸网络”，可以用于很多目的，比如发大量垃圾邮件。

​	当组成僵尸网络的时候，可以用别人电脑的计算能力和电费挖Bitcoin，或者发起“拒绝服务攻击”，简称DDoS，攻击服务器。

​	DDoS就是僵尸网络里的所有电脑发一大堆垃圾信息，堵塞服务器，要么迫使别人交钱消灾或者纯粹为了作恶。

### P33	加密

#### 12.密码学

##### a.概念

​		为了加密信息，要用加密算法把明文转化为密文。把明文转化成密文叫“加密”。把密文恢复回明文叫“解密”。

​	加密算法早就在计算机出现之前就有了。

​	为了解密，接受者要知道发密文的人用了什么算法，要偏移的字母位数。

##### b.算法

###### 	i.替换加密

​	有一大类算法叫做“替换加密”。凯撒密码就是其中一种，算法把每个字母替换成其他的字母。

​			缺点：字母出现的频率是一样的。

###### 	ii.移位加密

​	另一类加密算法叫做“移位加密”，解密的关键是知道读取方向和网格大小是5x5。

###### 	iii.替换加密

​	替换加密：通过机器将不同的字母连接起来，对应的各不相同,一个转子对应一个输出。也可以多个这样的东西放在一起，这个转子的输出作为下一个转子的输入。而且有26个输入，可以按照不同的顺序放入转子，提供更多的字母替换映射。在转子之后是一个叫做“反射器”的特殊电路，它的每一个引脚都会连接到另一个引脚，并把信号发回给转子。最前可以增加一个插板，，可以把输入的字母预先进行替换。这样的算法当中解密与加密是双向的，即解密与加密的步骤是一致的，只需要确保发送机与接收机的配置相同即可。

​	缺点：字母加密后必定成为某个字母。

​			为了解决这个缺点，设置了每输入一个字母，格子就会转一格。

#### 13.密钥交换学

​	随着计算机的出现，加密从硬件转向了软件，早期加密算法当中，用最广的是“数据加密标准”。

​	DES最初用的就是56bit长度的二进制秘钥。

​	2001年出现了高级加密标准AES，使用更长的密钥。

​		AES将数据切成一块一块，每块16字节，然后用密钥进行一系列替换加密和移位加密，每一块数据都重复操作十次以上。

​	 密钥交换：一种不发送密钥，但依旧让两台电脑在密钥上达成共识的算法。

​			例子：首先由公开的值--->基数和模数，双发提供各提供一个基数，然后再得到一个结果，只有两人知道。双方用一样的密钥加密和解密消息，叫做“对称加密”，因为密钥相同。还有非对称加密，有两个密钥，一个是公开的，一个是私有的，人们用公钥加密，只有有私钥的人才能解密。 

### P34	机器学习&人工智能

#### 14.机器学习

##### 	本质

​			机器学习算法可以让计算机从数据中学习，然后自行作出预测和决定，

##### 	地位

​			人工智能前的一大科技。

##### 	分类

​		做分类的算法叫做“分类器”，“特征”是来帮助“分类”的值。

​		为了分类器做得更好，我们需要“训练数据”。

​		专家记录数据的时候不仅记录特征值，还会将种类也记录上，这叫做“标记数据”。

​		对特征的划分边界的线叫做“决策边界”。 用一个表格展示有多少部分在所划定的范围之内，这个表格叫做混淆矩阵。

##### 	目的

​		最大化正确分类+最小化错误分类。

​	只记录数据特征，但并未记录种类的数据叫做“未标签数据”。

​	“决策树”和“支持向量机”这样的技术发源于统计学。

#### 15.神经元网络

​	但是也有不使用统计学的算法，最是人工神经网络，灵感起源于大脑里的神经元。

​	算法调整一些随机值和权重，从而训练神经网络，使用标记数据来训练和测试。

​	神经元有激活函数，也叫做传递函数，会应用于输出，对结果进行最后一次修改。

​	弱AI或窄AI，只能做特定任务，但不意味着没用、

​	真正通用的是像人一样聪明的，叫做“强AI”。

​	学习什么管用，什么不管用，自己发现成功的策略，叫做“强化学习”。

### P35	计算机视觉

#### 16.计算机视觉

##### 	a.诞生

​		视觉是信息最多的感官，所以计算机科学家研究使计算机拥有视觉，所以诞生了“计算机视觉”这个领域。

##### 	b.目的

​		让计算机理解图像和视频。

##### 	c.图像

​		计算机上的图像是由像素组成的，颜色有三种基本色（红蓝绿）组成，通过组合三种颜色的强度，可以得到任何颜色，也叫RGB值。

​		简单的计算机视觉是跟踪一个颜色物体：首先记录球的颜色，保存最中心像素的RGB值，将图像喂到程序里面，让它找最接近这个颜色的像素。这种一般很少用，缺点比较明显，当环境影响大的时候会完全失效。

​	“核”或“过滤器”的其中一种，通常将像素块对应的地方乘以方格中的数字，然后相加，放在中央，例如下：

​	![CC43D478872813C881F97A5682F2A9DB](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccCC43D478872813C881F97A5682F2A9DB.jpg)

#### 17.神经网络

​	最基本单位是神经元。他有多个输入，然后会把每一个输入，乘一个权重值，然后求总和。

​	神经网络可以学习对自己有用的“核”，来识别图像的特征。

​	卷积神经网络用一堆神经元处理图像数据，单次有多个神经元进行卷积，然后重复多次，每次都进行不同的卷积，在上一次卷积的基础上发现新的东西，在最后把所有特征放到一起。

​	卷积神经网络不是非要很多很多层，但一般会有很多层，来识别复杂物体和场景，所以这算“深度学习”。

​	计算机通过视觉感知周围的例子：计算机通过神经网络对人脸识别，通过多方面因素，如眉毛、嘴巴等等来判断你的情况，做出相应的反应。

​	**抽象是构建复杂系统的关键。**

### P36	自然语言处理

#### 18.自然语言

##### 	概念

​		人类的语言叫做自然语言，自然语言有大量词汇以及不同口音。

##### 	与计算机相关

​		让人的语言是计算机能听懂是从构思计算机开始就有了的，自然语言处理因此诞生，简称NLP。

##### 	NLP发展

​		早起主要研究如何将句子切成一块一块的。对于不仅仅有单词，还有各种语法结构存在的情况下，开发了“短语结构规则”。来代表语法规则。用这些规则，可以做出“分析树”。

​		把语言拆分开来，方便计算机处理。计算机可以回答问题以及处理命令。

​		当数据存在语义信息网络时，“短语结构规则”和其他把语言结构化生成句子的方法特别有效。

​		处理、分析、生成文字是聊天工具人的最基本部件。早起计算机机器人是按照规则回答，用基本句法规则来理解用户打的文字，然后向用户提问。

​		计算机怎样从声音中提取词汇是语音识别领域，

​		随着计算机的发展，语音识别变得可行，也出现了处理自然语言的新算法，不再是手工制定规则，而是用机器去学习，从语言数据库中学习。

​		从声波的波形到频率的转换，是用快速傅里叶变换（FFT）做成的。

​		在频率图中，从底往上看，标出高峰，叫“共振峰”。

​		构成单词的声音片段叫做“音素”。

### P37	机器人

#### 19.机器人的定义

​	由计算机控制，可以自动执行一系列动作的机器

​	潜在含义是存在于现实世界中的机器。

#### 20.发展

​	自动机不用电，而且没有电子元件。

​	第一台计算机控制的机器，出现在1940年代晚期，由计算机数控的机器简称为CNC机器。可以执行一系列程序指定的操作，CNC机器大大推进了制造业，不仅提高了制造能力和精确度，还降低了成本。

​	第一个商业贩售的可编程工业机器人叫Unimate于1960年卖给通用汽车公司，他可以把压铸机做出的热金属成品提起来，然后堆起来，机器人行业从此开始。

#### 21.负反馈回路

##### 	1)概念

​			询问并且有回答且关于回答有一定的行为的回路。

##### 	2)重要组成部分

​			a.一个传感器，可以收集想要获取的数据信息，比如水压、马达位置、气温等等，通过计算目标与实际的差距，等到一个“错误”，

​			b.对于返回错误时，控制器对其进行处理，操作使得如何减小错误

​			c.控制其作出的决定将下放到其他物理组件上，由它们做出动作。

#### 22.比例-积分-微分控制器

​	一般简称为PID控制器。

##### 1)产生原因

​		在现实环境当中，机器人会受到各种外力因素的影响，而需要处理这些因素带来的影响，需要更加复杂的控制逻辑。

##### 2)操作

​		对于实际与现实，PID控制器首先会给出一个“比例值”，也就是“实际值”（可能是滞后的或者实时的）与“理想值”的差距；其次是“积分值”，也就是一段时间内的误差总和；最后是“导数值”，也就是期望值与实际之间的变化率，有助于解决未来可能出现的问题，也叫做“预计控制”。

​		三个值一起来使用，各自有不同的权重，来控制系统。

##### 3)用处

​		高级机器人一般需要多个控制回路同时运行，来保持机器人平衡。

​		有智力并且可以杀人的机器人叫做“致命自主武器”。

#### 23.阿西莫夫三定律

​		也叫机器人三定律

##### 	1)用处

​			指导机器人的行为准则或者说是道德指南。让机器人不要伤害，特别是不要伤害人类。

##### 	2)缺点

​			规则实现起来相当不足，并且有很多模糊的地方。

##### 	3)影响

​			激发了大量科幻小说讨论和学术讨论

##### 	4)内容

​			第零定律：机器人必须保护人类的整体利益不受伤害，其它三条定律都是在这一前提下才能成立。

​			第一定律：机器人不得伤害人类个体，或者目睹人类个体将遭受危险而袖手不管。

​			第二定律：机器人必须服从人给予它的命令，当该命令与第一定律冲突时例外。

​			第三定律：机器人在不违反第一、第二定律的情况下要尽可能保护自己的生存

##### 	5)补充与修改

​		本处以及上面的阿西莫夫三定律摘自百度百科https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E4%B8%89%E5%AE%9A%E5%BE%8B/10969803?fromtitle=%E9%98%BF%E8%A5%BF%E8%8E%AB%E5%A4%AB%E4%B8%89%E5%A4%A7%E5%AE%9A%E5%BE%8B&fromid=8570149&fr=aladdin

​		这是由之后的人进行的。

​			第四原则：机器人在任何情况下都必须确认自己是机器人。

​			第四原则：机器人必须进行繁殖，只要进行繁殖不违反第一原则、第二原则或者第三原则。

​			第五原则：机器人必须知道自己是机器人。

​		后续还发展出一些其他的人定义的定律

​			罗杰·克拉克构思的机器人原则：

​				元原则：机器人不得实施行为，除非该行为符合机器人原则。

​				第零原则：机器人不得伤害人类整体，或者因不作为致使人类整体受到伤害。

​				第一原则：除非违反高阶原则，机器人不得伤害人类个体，或者因不作为致使人类个体受到伤害。

​				第二原则：机器人必须服从人类的命令，除非该命令与高阶原则抵触。

​				机器人必须服从上级机器人的命令，除非该命令与高阶原则抵触。

​				第三原则：如不与高阶原则抵触，机器人必须先保护上级机器人，再保护自己之存在。

​				第四原则：除非违反高阶原则，机器人必须执行内置程序赋予的职能。

​				繁殖原则：机器人不得参与机器人的设计和制造，除非新机器人的行为符合机器人原则。

##### 	6)对机器人评价

​		《我，机器人》的中心概念是机器人没有问题，科技本身也不是问题，人类逻辑的极限才是真正的问题。																								-------威尔·史密斯

### P38	计算机心理学

#### 24.引出

​	为了设计出令人使用愉快的计算机，系统设计师在创造软件的时候，会运用社会心理学、认知心理学、行为心理学、干事心理学的原理。

#### 25.界面设计

##### 1)易用度

​	易用度指的是人造物体，比如软件达到目的的效率有多高

##### 2)分块

​	分块是指把信息分成更小，更有意义的块。

​	从计算机的角度看，分块更费时费空间，效率更低，但对于人类更有效率。

##### 3)直观功能

​	 直观功能为如何操作物体提供线索，直观功能做得好，用户只需要看一下就知道该怎么做，不用图片、标签或者指南来说明如何操作。

​	直观功能广泛应用于图形界面。

​	和“直观功能”相关的一个心理学概念是“认出与回想”。

​		一般来说，用感觉来触发记忆会容易很多，所以一般用图标代表功能。命令行得靠记忆输入。

​	又与另一个心理学的概念冲突“专业知识”，好的界面应当有多种方式来实现建立如何高效完成事情的“心理模型”。

##### 4)令计算机有“感情”

​	计算机检测你的身体情况，将得到的数据和计算机模型结合使用，模型会写明人类如何表达情感，怎么是快乐怎么是沮丧以及社交状态，比如友谊和信任。

#### 26.CMC领域

​	以计算机为媒介沟通领域。

####  27.心理学

1)相互凝视

​		在谈话时看着别人叫“相互凝视”。

​		被证明可以促进参与感，帮助实现谈话目标。

2)增强凝视

​		研究人员开发计算机视觉和图形软件来纠正头部和眼睛，使视频是觉得对方在看着自己

#### 28.HRI领域

​		是研究人类与机器人互动的领域。

### P39	教育科学

#### 19.零散点

​	计算机带来的最大改变之一是信息的创造和传播能力。

​	远距离教育一直推动着教育科技的发展。

#### 30.高效学习

​	研究表明有些很简单的事情可以显著提高学习效率：

​		1)把速度调到适合自己；

​		2)暂停，再看不懂的地方暂停

​		3)做视频中的提供的练习

#### 31.智能辅助系统

​	通过AI来对学生不会的进行推断，将用户没有理解的进行给出。

​	一般的话，是根据用户选出的答案，使用算法或者一些“判断规则”相结合，判断可能的原因。

​		这些判断规则一般也是学生错误的地方，所以又叫做“错误规则”。

​	“判断规则”+选择算法，组合在一起成为“域模型”。它可以用来帮助学习者解决特定的问题，但它无法带着学习者以正确的顺序搞定整个学科上的所有课程。，因为域模型不记录进度。

​	因此，智能辅导系统负责创建和维护学生模型，记录学生已掌握的判断规则以及还需练习的生疏部分。

​	“贝叶斯知识追踪”常用来解决学生知道什么了解什么这个问题。这个算法把学生的知识当作一组隐藏变量，这些变量的值对外部是不可见的。他会记录四个概率：学生已经学会的概率，瞎猜的概率，失误的概率，做题中学会的概率。利用这四个概率来对学生的技能进行评估。

​	常使用这个算法来让学生进行练习，直到掌握，利用自适应程序，一种个性化的算法，

### P40	奇点

32.普适计算的愿景

​		计算机随处可见，不仅在家中，包里，厨房，甚至到你的衣服、血液中。

​		在这样的路上，有人走的无形，将计算机整合到所有的东西里面，用的时候很自然，完全注意不到，最厉害的科技是看不见的科技。

#### 33.关于人工智能

​	“智能”是难以量化的指标。人类更喜欢用处理能力来区分，但这样又比较“已计算为中心”。

#### 34.奇点

​	智能科技的失控发展叫做“奇点”。

#### 35.复杂度刹车

​	由于发展到后面复杂度越来越高，发展趋势不会是指数型，而是S型。微软联合创始人保罗·艾伦将其称为“复杂度刹车”。

​	当计算机发展的越来越强大，可能在未来将出现超智能计算机，有人迫不及待地期待着这个时代的来临，而有人却极力阻止着，最直接的影响可能是“技术性失业”。

​	超人类主义者认为会出现“改造人”，人类和科技融合在一起，增强智力和身体。

​	也有人预见“数字永生”，人类肉体死亡，意识上传到计算机上

# Linux系统编程笔记

虚拟机的IP:192.168.142.128

## （一）P1--P37

云里云外博客地址：https://www.yunliyunwai.cn/blog/detail/0c3c23dad8e704df0bbc552f052edd18

### 1.终端

​		概念：终端是一系列输入和输出设备的总称。

​		电脑屏幕上打开的编辑框叫做虚拟终端，为模拟计算机行为而存在的。

​		虚拟终端里内置了一个shell。

### 2.shell

​		命令解释器，根据输入的命令执行相应的命令。

​		cat  /etc/shells   该命令可以查看当前操作系统支持的shell类型

​		echo $SHELL($表示去环境变量的值)  该命令可以查看当前所使用的shell类型。

### 3.TAB

​		可以用来命令和路径补全

​		单按一次可以进行补全，但当按了一次没反应，则证明一次开头的命令不止这一个，可以按第二次，会出现所有一次开头的命令。

### 4.方向键（上下）

​		可以调用你执行过的命令。

### 5.快捷键

​		Ctrl+p		上

​		Ctrl+n		下

​		Ctrl+b		左

​		Ctrl+f		右

​		Ctrl+d		删除光标后的

​		Ctrl+a		跳转开头

​		Ctrl+e		跳转最后

​		Ctrl+u		直接清除命令

6.目录

​	bin			 存放二进制可执行文件

​	boot		   存放开机的启动历程/程序

​	dev			设备文件

​	etc			 用户相关的配置文件信息

​	home		 用户目录

​	lib			  库路径

​	media/mnt	挂载/卸载磁盘相关，自动挂载会到media上，可以自行挂载到mnt上

​	usr			用户所安装的第三方软件

### 7.注意

​		所见皆文件

​		操作系统给每一个文件赋予唯一的inode,当有相同的inode 的文件存在时，彼此同步。

​		文件存在磁盘内最少占用512字节(一个块)。

### 8.dev

​		input中有各种外接设备，比如鼠标（mice）键盘等等，当cat去读取文件信息的时候会在终端输出文件使用情况。

### 9.etc  

​		passwd 内存放着用户信息

### 10.路径

1)绝对路径

​		从根目录开始描述的路径

2)相对路径

​		从当前位置开始描述的路径

### 11.命令

#### 	1)ls

​		展示当前目录信息

​		-l	详细信息

​		-a	隐藏文件

​		-d	显示目录

​		-R	递归查看（会将含有子目录的也展开）（于r操作并不相同）

​		-h     以人类可读方式读取，一般将文件大小变为K/M/G

#### 	2)which

​		查看指定命令所在的路径

#### 	3)pwd

​		查看当前所在路径

#### 	4)rmdir

​		删除空目录

#### 	5)touch

​			文件不存在，创建一个空目录

​			文件存在，将访问及修改时间都更新

#### 	6)cat 

​			查看文件内容

​		tac	--->倒着查看文件（仅将行数倒着，每行内容不变）

#### 	7)cp

​			将文件拷贝为新文件

​			拷贝文件到某个目录下

​			拷贝的目录非空时要用   cp -a  文件  ..

​								为空时可用  cp  文件  ..（目录非空会略过目录）

#### 	8)more

​		查看大文件，可以分开显示一屏，并提示查看进度

​		回车---->下一行

​		空格----->翻页

​		Ctrl+C或者p  结束查看文件

#### 	9)less

​		查看大文件，显示一屏，可按上下键向上或向下。

​		p退出

#### 	10)head

​			从前往后查看可在head后加	-25(表示前25行)，默认为10行。

#### 	11)tail

​			从后往前查看可在tail后加	-25(表示前25行)，默认为10行。

#### 	12)tree

​			将当前目录以树状展开。(本命令需要安装)

​			安装使用	sudo yum -y install tree

#### 	13)du

​			显示磁盘

#### 	14)df

​			显示磁盘剩余空间

#### 	15)whoami

​		查看当前登录用户

#### 	16)chmod

##### 		i)文字设定法

​			用于修改文件属性

​			u---用户（文件或目录所有者）

​			g---同组用户（文件属性主有相同组ID的所有用户）

​			o---其他用户

​			a--所有用户

​			使用示例：chmod u+x 文件（为文件的所有者添加执行权限）

##### 		ii)数字设定法

​			r---4		w---2		x---1

​			使用示例：chmod  471  文件（-r--rwx--x）

#### 	17)chown

​			修改文件的所有者和所属组

##### 		i)创建用户（组）

​		sudo adduser 新用户名

​		sudo addgroup 新组名

##### 		ii)修改文件所属用户（组）：

​		sudo chown 新用户名 待修改文件

​		sudo chgrp 所属组名  待修改文件

##### 		iii)一次性修改文件所属用户和所属组

​		sudo 用户名：用户组  待修改文件

##### 		iv)删除用户

​		sudo  userde  -r 用户名 

​		-r作用：把用户的主目录一起删除

##### 		v)删除用户组

​		sudo delgroup 用户组名

vi)设置密码

​		sudo  passwd  用户名

vii)切换用户

​		su  用户名

viii)root用户

​		sudo  su

​	设置root密码

​	passwd	

#### 18)find

​		find  ./  -maxdepth  1  -name '*`jpg'   	此处含义为“在当前目录下（深度为1，即最多向里打开几个文件夹），寻找名字中以.jpg结尾的文件”。

​		name也可以用type更换，类型是看文件权限中开头的文件类型。

​		如果没有	maxdepth	1	,find会一直向文件下寻找，直到找出所有的符合条件的文件

​		find  ./  -size  +20M -size -50M    在本目录下搜索文件大小为20~50M的文件

​		文件大小有k、M、G(注意k为小写，而M、G为大写)，默认为b(block，512个字节)

​		find  ./  -ctime  1		一天以内修改的文件

​		atime---->最近访问时间

​		mtime---->最近更改时间（属性）

​		ctime---->最近改动时间（内容）

​		find  /usr/  -name   " ***** tmp ***** "  -exec  ls  -ld  {  }  \;     在用户文件夹内按名字搜索tmp文件，并执行	ls  -l  命令；{  }  的作用：盛放前面找到的文件，\为转义字符，"**;**"表示语句结束。

​		find  /usr/  -name   " ***** tmp ***** "  -exec  rm  -rf  {  }  \;   将搜索到的文件全部删除，但exec会询问是否删除有写保护的文件，且无法撤销复原。如果将	-exec	换为	-ok	就会对每个文件进行询问是否删除。

​		-exec	将find搜索到的结果集执行某一命令

​		-ok 	   以交互式的方式，将find搜索到的结果集执行某一命令。

19)xrage

​		于exec类似，但略有不同，需和19、21、22一起实用更佳！！！

​		-xarge   将find搜索到的结果集执行某一命令 ，好处是当结果集数量过大时可以分片映射。（前面要加“	**|**	” ）。当遇到空格时会拆分，解决方法：

​		find  ./  -maxdepth  1  -type  f  -print0  |  xarges  -print0  ls  -ld

​		解释：将NULL作为拆分的依据，而是不将空格作为拆分依据。

#### 20)man

​		可以查看各种命令或操作的详细信息及使用

​		对于一些难度较大的命令，在其中会有一些例子（example）

​		man有九章命令

​		如果要确定某一章内容		man  章数	命令名字

​		man的级别：

​			**1：**查看可执行程序或shell命令的帮助	

​			**2：**系统调用（查看可被内核调用的函数的帮助）

​			**3：**库调用（查看函数和函数库的帮助）

​			**4：**查看特殊文件的帮助（主要是/dev目录下的文件）

​			**5：**查看配置文件的帮助

​			**6：**查看游戏的帮助

​			**7：**查看其他杂项的帮助（包括宏包和规范，如man(7),groff(7)）

​			**8：**查看系统管理员可用命令的帮助

​			**9：**查看内核相关文件的帮助

#### 21)gerp

​		找文件内容

​		grep  -r   '要搜索的内容'	搜索的目录	-n

​		 -r   表示递归

​		-n    显示行号

#### 22)ps

​		搜索后台进程，相当于windows的任务管理器。

​		ps   选项

![image-20211201105806783](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211201105806783.png)

​		可以和grep 结合使用如：

​		ps  aux  |  grep   '内容'

​		当只搜索到一条内容时，说明后台并无此名称的进程运行。

#### 	23)awk	sed

​		注：需要使用正则表达式，现在还没搞;而且是属于脚本语言

​		awk   是按照行拆分

​		sed    是按照列拆分

#### 24)who

​		查看当前线上用户情况，当没有限定命令时，默认为全选

​		显示三项内容：登陆用户名、使用终端设备、登陆到系统的时间

#### 25)jobs

​		显示当前shell下正在运行哪些作业（即后台作业）

#### 26)fg

​		fg  [job···]

​		把指定的后台任务切换到前台

#### 27)bg

​		bg  [job···]

​		把挂起的进程提到后台执行。

#### 28)top

​		任务管理器

#### 29)网卡

​	i)查看网卡信息	ifconfig

​	ii)关闭网卡		  sudo  ifconfig  eth0  down

​	iii)开启显卡eth0	sudo  ifconfig  eth0  up

​	iv)给eth0配置临时IP	sudo  ifconfig  eth0  IP

#### 30)ping

​		ping  [选项]  主机名/IP地址

​		查看网路上的主机是否在工作。

#### 31)clear

​		清屏，也可用快捷键Ctrl+L

#### 32)alias

​		起别名

​		将某个字符串定位某些命令，可以快捷使用

​		alais  字符串='命令'

#### 33)umask

​		umake指定用户创建文件时的掩码

​		一般是反着来的，但默认文件没有执行权限，在用777减去数字后将判断出来的类型中的x去掉

#### 34)终端

​		创建终端标签：Ctrl+Shift+t

​		切换标签：Alt+n(n=1)

​		新开终端：Ctrl+Shift+n

#### 35)history

​		查看曾经执行过的所有命令























​			

### 12.Linux系统文件类型(7)

​		普通文件			  -

​		目录文件			  d

​		字符设备文件		c

​		块设备文件			b

​		软连接					l

​		管道文件				p

​		套接字					s

​		其余均归为未知

### 13.如何将Linux中终端的#/$前的东西去除

​		在家目录下vi  .bashrc  在最后一行将上面其中一行的内容复制，并将前面的#删除，保存退出，再重启终端即可。（仅供参考）

### 14.软连接

​		ln   -s  文件

​		创建出来的软连接相当于Windows下的快捷方式

​		用相对路径创建的软连接仅可在当前目录内寻找文件。

​		只有用绝对路径创建的软连接才可在任意目录内访问文件

### 15.硬链接

​		直接使用	ln    	目标文件	生成文件

​		硬链接会使得应用计数增加

​		修改硬链接内部文件也会使得原文件被修改

​		删除原文件硬链接依旧可以使用

​		删除只会使硬链接计数减1，当减为0时，inode被释放

### 16.软件的卸载与安装

##### 1)apt-get

​	 i)联网状态下从网上将全部安装信息拷贝

​	 ii)更新软件资源到本地：sudo  apt-get update

​	 iii)安装	sudo  apt-get  install  软件名

​	 iv)卸载     sudo  qpt-get remove  软件名

​	 v)一些命令

​			更新源服务器列表：   sudo  vi  /etc/apt/aources.list

​			更新完服务器列表后需要更新下载源

##### 2)deb包安装

​			unb下的所有安装包都以此方法安装

​			先在网上下载这样一个安装包，再使用安装命令完成安装

![image-20211201114311420](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211201114311420.png)

##### 3)离线安装

​		ls或LS

##### 4)源码安装

![image-20211201114725334](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211201114725334.png)

### 17.压缩与解压缩命令

​		压缩式可以将多个文件一起压缩

​		注：bizp和gzip均是只可对单个文件（不可对目录，且不能打包）进行压缩

​		**常见压缩格式：**.zip	.gz	.bz2

​								.tar.gz		.tar.bz2

#### 		1)	.zip	格式压缩包	

##### 				i)zip	格式压缩

​			**注：**Linux中软件包（不局限于压缩包）用红色显示名字。

​			**注：**压缩文件时可以不写压缩文件的后缀，但应该写上后缀名，以防之后不清楚该文件是否为压缩文件。

​			zip	压缩文件名	源文件

​				#压缩文件

​			zip	-r	压缩文件名	源目录

​				 #压缩目录

##### 			ii)unzip	格式解压缩				

​				unzip	压缩文件

​					#解压缩.zip文件

#### 2）	.gz	格式

​			**格式：**			

​			gzip	源文件

​			#压缩为	.gz	格式的压缩文件，源文件会消失

​			gzip	-c	源文件	>	压缩文件

​			#压缩为  .gz  格式，源文件保留

​				例如：gzip	-c	cangls	cangls.gz

​			 gzip	-r	目录

​				#压缩目录下所有子文件，但是不能压缩目录

#### 3）	.bz2	格式压缩

##### 		i)	.bz2		格式压缩文件

​			bzip2		源文件

​		#压缩为	**.bz2**	格式，不保留源文件

​		bzip2	-k	源文件

​		#压缩之后保留原文件

​			**注意：**	bzip	命令不能压缩目录

##### 			ii)bzip2	格式解压缩

​			bzip2	-d	压缩文件

​				#解压缩，-k保留压缩文件

​			bunzip2	压缩文件

​				#解压缩，-k保留压缩文件

#### 		4)tar	打包命令

##### 			i)打包目录及文件

​				tar	-cvf	打包文件名	源文件

​				选项：

​						-c:	打包

​						-v:	显示过程

​						-f：	指定打包后的文件名

​				例如：

​						tar	-cvf	longzls.tar	longzls

##### 				ii)解打包命令

​					tar	-xvf	打包文件名

​					选项：

​								-x：解打包

​					例如：

​							tar	-xvf	longzls.tar

#### 		5)	.tar.gz	压缩格式

​				其实  .tar.gz  格式是先打包为  .tar  格式，在压缩为.gz格式

​					tar	-zcvf	压缩包名  .tar.gz  源文件

​				选项：

​						-z:	压缩为  .tar.gz  格式

​					tar	-zxvf	压缩包名 .tar.gz

​					选项：

​							-x:	解压缩 .tar.gz  格式

​					tar	-ztvf	压缩包名.tar.gz

​						可以查看压缩包里的内容

#### 			6）	.tar.bz2压缩格式

​				tar	-jcvf	压缩包名为	.tar.ba2	源文件

​				**选项：**

​						-z:	压缩为	.tar.bz2	格式

​				tar	-jxvf	压缩包名.tar.bz2（可在后面加	-c	指定解压缩位置）

​				**选项：**

​						-x：解压缩	.tar.bz2	格式

​					注：若要同时压缩多个文件可以放在一起，还可以指定压缩到的位置，只要在压缩包前加上绝对路径即可。

​				tar	-jtvf	压缩包名.tar.bz2

​					可以查看压缩包里的内容

#### 7)rar

​	i)打包

​			rar  a  -r  压缩包名(带.rar后缀)  压缩材料 

​	ii)解包

​			unrar  x  压缩包名

### 18.如何查看软件是否安装

​		先安装查看命令：sudo apt-get install aptitude

​		sudo aptitude show 安装内容  ----->可以产看是否安装以及安装信息等等

### 19.VIM的使用

#### 	1)介绍

​		vim含有三种模式**命令模式、文本输入模式、末行模式**：

​		文本输入模式可以向文件中增减内容；

​		命令模式可以进行一些操作（如：删除行，撤销操作，定位行等等操作）；

​		末行模式可以保存退出，显示或隐藏行数等等；

#### 	2)开启

​		**vim  文件名**（也可以输入一部分，按tab自动补全）

​		**vim	+n  文件名**（可以使文件打开时定位到第n行，如果n大于最大行数，则会定位到最后一行）

​		**vim    +/imooc   文件名**（再打开文件会自动定位到该字符串第一次出现的位置，再按可以定位到下一次出现的位置）

​		**vim  文件名  文件名  文件名**（可以打开或创建多个文件，在命令模式输入**n**即可切换到下一个文件，但只可单项切换，不可切换到上一个文件；输入**N**或者**prev**可以切换到前一个文件）

#### 3)模式切换

从文本输入模式或者末行模式切换到命令模式：按**esc**

从命令模式切换到文本输入模式：按	**i**	键

从命令模式切换到末行模式：输入	**：**或	**/**

#### 4)快捷键使用

###### i)复制粘贴

​	拷贝当前行**yy**	拷贝向下的五行为**5yy**	粘贴为	**p**(向后粘贴)	/	P(向前粘贴)	[命令模式]

​	删除当前行	**dd**	删除向下的五行为	**5dd**	[命令模式]		删除的实质其实是剪切

###### ii)查找替换

​	在文件中查找某个单词  输入	/关键词	再按回车，按n为下一个	[末行模式]

​	查找某一个见到的字符或字符串在后续的使用	将光标定在该字符或字符串上，按	*****/**#**	跳转到下一个		[命令模式]

​	替换单个字符	将待替换的字符用光标选中，按  **r**  ，再按欲替换的字符	[命令模式]

###### iii)移动光标位置

​	设置文件的行数	**set  nu**  	取消文件的行数    set  nonu		[末行模式]

​	快捷到首行	**gg**	  快捷到尾行	**G**		[命令模式]

​	光标移至行首	0	行尾	$	[命令模式]执行结束，模式不变

​	单行部分内容替换		光标置于目标行上，输入：s  / 原数据/新数据	[末行模式]

​	多行替换部分内容统一替换		：%s   /原数据/新数据/g	g：不加，只替换每行首个	[末行模式]

​	目标行替换		：起始行号，终止行号s   /原数据/新数据/g		[末行模式]

​	将光标移动到固定行	**20  shift+g**	将光标移到20行处	[命令模式]

###### iv)命令模式常用指令

{

​			h		左移

​			j		下移

​			k		上移

​			l		右移

​			ctrl+f			向下翻页（front）

​			ctrl+b			向上翻页(back)

​			ctrl+d			向下翻半页(down)

​			ctrl+u			向上翻半页(up)

​			o  				  在光标所在行的下方插入一行并切换到输入模式

​			p（小写） 	在光标所在行的下方粘贴

​			P（大写）	  在光标所在行的上方粘贴

}

###### v)切换为之前的命令

​	上一条	ctrl+p

​	下一条	ctrl+n

###### 	vi)末行模式常用命令

​		保存并退出				**:wq**		[末行模式]

​		强制退出					**:q!**	 	[末行模式]

​		退出当前文件  			**:q** 	 	[末行模式]

​		强制执行					  **:!**	  	[末行模式]

​		将文件写到硬盘中		**:w**		[末行模式]

​		列出当前编辑器中打开的所有文件	**:ls**	  [末行模式]

​		快速定位光标					**:15**		[末行模式]

​		从光标开始向前搜索字符串	?xxx	[末行模式]

###### 	vii)其余命令

​	自动格式化程序		gg=G[命令模式]

​	大括号对应	%		[命令模式]

​	删除单个字符	x	[命令模式]执行结束模式不变

​	删除一个单词		dw[命令模式]光标置于首字母进行操作

​	删除光标至行尾	D或d$[命令模式]

​	删除光标至行尾	d0[命令模式]

​	删除区域字符	按V进入可视模式，再用hjkl移动光标选中区域，最后按d删除	[命令模式]

​	撤销操作	**u**		[命令模式]	反撤销	Ctrl+r	[命令模式]

###### viii)**分屏操作**	

​			在分屏操作的sp/vsp后加上文件名即可建立一个新文件	

​		上下分屏	sp		[末行模式]		切换Ctrl+ww	[命令模式]	去除当前这个分屏	q	[末行模式]

退出分屏且关闭文件	wqall

​	 	左右分屏	vsp	[末行模式]

​	在文件内查看某个语句的帮助文档（man手册）	光标定位单词	按	(需要的文档第几卷)+K	[命令模式]

​	查看宏定义		将光标置于带查看宏定义单词	用	[d	查看定义语句

###### ix)在末行模式执行shell命令

​		：！命令

###### x)更改vim配置

​	更改	/etc/vim/vimrc	或者~、.vimrc		相比较，~/.vimrc的优先级更高

### 20.gcc使用

#### 	1)编译四步骤

##### 		i)介绍

​				gcc编译可以执行程序的四步骤：预处理、编译、汇编、链接

​				hello.c--预处理-->hello.i--编译-->hello.s--汇编-->hello.o--链接-->hello.c

​				gcc  (-E/S)  需使用的文件	-o  文件生成的名字

​				-o是指定文件的生成名

##### 		ii)预处理

​				展开宏、头文件，替换条件编译，删除注释。空行、空白	gcc   -E

##### 		iii)编译

​				检查语法规范																			gcc   -S				消耗时间和系统资源最多

##### 		iv)汇编

​				将汇编指令翻译为机器指令													  gcc   -c

​				汇编文件的查看：	objdump  -dS  汇编文件名

##### 		v)链接

​				数据段合并、数据地址回填													（无参数）

###### 				a)地址回填

​		例子：

​				int main{

​						func1();		

​						func2();

​				}

![image-20211204135612574](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211204135612574.png)

###### 				b)数据段合并

​				以32位操作系统为例

​				0~ 3G为用户空间，3~4G为内核空间（kernel）

​				.text     ---->代码段    ro

​				.rodate    ----->只读数据区  ro

​				.date      ---->数据区 （已初始化） 		rw

​				.bss	--->数据区（通常是指用来存放程序中未初始化的或者初始值为0的全局变量的一块内存区域）	rw

​				heap   --->堆	从低地址指向高地址

​				stack   --->栈		从高地址指向低地址

​				一页（page）----->4K

![image-20211204155501383](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211204155501383.png)

​		注：使用gcc编译过程中会出错的两个步骤：编译、链接------->编译出错是语法的错误，会出现行号信息；但当链接出错时，不会出现行号信息出现collect2之类的

#### 	2)gcc常用参数

​		i)指定头文件所在位置		

​				gcc  -I	位置	需使用的文件	-o  文件生成的名字	或者	gcc需使用的文件	-o  文件生成的名字	-I	文件位置

​		ii)只做预处理、编译、汇编		-c		得到二进制文件

​		iii)编译时添加调试语句				-g 	支持gdb调试

​		iv)编译优化				-0n（n为0~3,数字越大，优化程度越大，但如果过程有用的话也会导致一些问题）

​		v)提示更多警告信息		-Wall

​		vi)向程序中“动态注册”宏定义	-D	一般用作开关调试

### 21.静态库和共享库

#### 1)好处

​		提高编译效率或程序编写效率

#### 2) 相比较

​		原理上来说，动态库调用速度比静态库慢

​		静态库用于对空间要求较低，而时间要求较高的核心程序中

​		动态库用于对空间要求较高，而时间要求较低

​		可以用	file	查看库文件

#### 3)制作静态库

##### 	i)命令

​		ar  rcs  libmylib.a  dile1.o

​		命名规范：库必须以	**lib**	开头，静态库必须以	**.a**	结尾

##### 	ii)制作操作

​		先定义一系列函数，再将写好的.c文件编译为.o（经过预处理、编译、汇编的）		例子：gcc  -c  add.c  -o  add.o

​		在用	ar  rcs  静态库文件名	做好的函数

​		可以用	file	查看库文件	正确的为current   ar  archive

##### 	iii)库的使用

​		在编译时将库文件名和文件名写在一起，且源码在库的前面

​		隐式声明，默认为int （编译器只会隐式声明只会用int）

##### 	iv)头文件首位

​				头文件首位的使用，可以防止重复包含头文件。

​				可参考：https://blog.csdn.net/lorachao/article/details/108135299?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163859448016780366516803%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163859448016780366516803&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108135299.first_rank_v2_pc_rank_v29&utm_term=%E5%A4%B4%E6%96%87%E4%BB%B6%E9%A6%96%E4%BD%8D&spm=1018.2226.3001.4187

#### 4)制作动态库

##### 	i)制作操作

###### 		a)做函数

​			将	.c  生成  .o  文件（生成与位置无关的代码  借助  -fPIC）

​			例子：gcc  -c  add.c  -o  add.o  -fPIC

###### 		b)用  gcc  -shared  制作动态库

​			gcc  -shared   -o lib库名.so    做好的函数

###### 	c)可以用	file	查看库文件

###### 	d)编译指定

​			编译可执行程序时，指定所使用的动态库。     -l -->用来指定库名  -L--->用来指定库路径

​			gcc  test.c  -o  a.out  -l  库名  -L ./lib

###### 	e)运行

​			运行可执行程序		./a.out			出错！！！！

###### 	f)出错原因：

​				链接器：			工作于链接阶段，工作时需要 -l和-L；

​				动态链接器：	工作与程序运行阶段，工作室需要提供动态库所在目录；

###### g)解决问题	

​		环境变量：LD_LIBRARY_PATH

一、		导出环境变量的新值		export  LD_LIBRARY_PATH =动态库路径

​			这样才可以成功（临时），但重开一个终端就有一次出错（因为重启之后环境变量失效了）

​			环境变量是进程的概念。

​			如果要想不会再出错，就要该配置文件，即在家目录下  vi  .bashrc  内将环境变量进行更改。

​			建议使用绝对路径。

​			使用	.  .bashrc  或  source  .bashrc  亦或重启终端  运行一次方可生效

​	二、将该动态库文件直接放到本来的环境变量的目录之下

​			ldd命令---->加载在程序运行之后，所用到的哪些动态库以及这些动态库的路径

​				当ldd命令寻找动态库，而动态库不存在时，就会出现not found

​	三、配置文件法：

​				vim	/etc/ld.so.conf  这个文件	但是这个文件对于一般用户是只读，此时要使用sudo或者root用户

​				在第二行内插入动态库文件所在的目录（要使用绝对路径）

​				更改完毕后，用  sudo  ldconfig  -v （显示所有动态库加载位置），使配置文件生效，这样就更改完毕了  ！！！

##### 	iii)注意

​		与地址回填--->[详看20-(1)-(v)-(a)]---不同，调用动态库的话，只有当时用到这个函数的时候才会在内存中有它的地址；

​		使用动态库，即使编译完成后，需要动态库的函数（比正常的函数多了个  **@plt**  ，其地址是需要这个东西的）依旧不会有地址，只有把动态库加载到内存中，才会存在地址；

​		有的书籍描述动态库的时候会写到“延迟绑定”，就是动态库要比自己写出的函数绑定地址的时间晚，是因为要对  **@plt**  再进行一次填充；

##### 	iv)结论

​			制作动态库的时候，我们要用到的  .o  文件和静态库的有差别

## （二）P38--P68

云里云外博客地址：https://www.yunliyunwai.cn/blog/detail/4f32e9f5fcf657252e186162b830c0c3

### 1.gdb调试

##### 1)使用条件

​	在编译时要加上gcc后	-g	选项方可使用gdb

##### 2)存在意义

​	检查程序当中的逻辑错误

##### 3)使用的键

​	注：当使用键位的时候，按回车是执行上一条命令。

###### 	i)list / l		

​		显示十行的内容，之后可以继续输入l。

​		默认从第一行开始显示，可以在后面加上数字来指定显示的首行。

###### 	ii)b  数字

​		设置断点

###### 	iii)run / r

​		输入且回车后，程序就会停止在设置的第一个断点处，且本条程序是处于待执行的状态。

###### 	iv)n

​		next，执行到下一条程序。

###### 	v)s

​		step，单步执行，对于函数就会进入到函数内执行函数的设置。

###### 	vi)n和s的区别

​		n不可以进入函数中，而s可以。对于是系统函数的时候，只能用n，如果使用s的话就会进入之后出不来了。

###### 	vii)p / print

​		打印某个量的数据。

###### 	viii)continue

​		继续向后执行，直到下一个断点，如果后续没有断点，就会直接执行完毕程序。

###### 	ix)quit

​		退出gdb当前调试。 

##### 4)其他指令

###### 	i)run的其他用法

​		使用run去查找段错误出现位置。

​		在后面加上所需的输入值，也可以作为main函数的命令行参数

###### 	ii)start

​		默认从main函数的第一行执行。

###### 	iii)finish

​		结束当前函数调用。

###### 	iv)set

​		set  args  数值  

​		设置main函数命令行参数

###### 	v)info

​		查看当前断点信息

###### 	vi)条件断点

​		b  行号  if  条件	---->当条件成立时，断点可用

###### 	vii)ptype

​		ptype  变量名    --->查看变量类型

​		当在局部变量设置之外的函数查看局部变量，会提示未设置此变量。

###### 	vii)栈帧

​		定义：随着函数调用而在stack上开辟的一片空间，用于存放函数调用时产生的局部变量和临时值。

​		当函数调用结束时，这个函数所使用的栈帧被释放内存。

###### 	ix)bt

​		backtrace		查看函数调用的栈帧和层级关系。

###### 	x)f

​		frame		切换函数的栈帧。

###### 	xi)display

​		display  变量名	--->跟踪某个变量的值

​		undisplay  正在跟踪的变量使用的编号	---->取消跟踪某个变量

###### 	xiii)d

​		delete  	删除断点

5)常见错误

​		使用list的时候显示没有符号表被读取---原因--->在编译的过程中没有加上-g选项，致使不可调试。

​			解决方法：1-->退出调试，重新编译

​							   2-->使用file命令进行可调试修改

### 2.Makefile

​		相当于一个脚本文件

#### 	1)用途

​		项目代码编译管理

​		节省编译项目时间

​		一次编写终身受益

#### 	2)命名

​			只能为以下两种---->Makefile/makefile

​			只有此命名可以使用默认的make命令

#### 	3)规则

​		目标：依赖条件

​							（一个Tab缩进）命令

#### 	4)基本原则

​	i)若想生成目标，检查规则中的依赖条件是否存在，如不存在，则寻找是否有规则用来生成该依赖文件。

​	ii)依赖条件的时间必须比目标的时间（修改）晚。检查规则中的目标是否被更新，必须先检查它的所有依赖，依赖中有任意一个被更新，则目标必须更新

​		具体步骤：i)分析各个目标和依赖之间的关系

​						  ii)根据依赖关系**自底向上**执行命令

​						  iii)根据修改时间比目标新---->确定更新

​						  iv)如果目标不依赖任何条件，则执行更新命令，以示更新。

#### 5)两个函数

​	src=$(wildcard *.c)----->咋好到当前目录下所有后缀为.c的文件，赋值给src

​	obj=$(patsubst  % .c,%.o,$(src))----->把src变量里所有后缀为.c的文件替换成.o	

#### 6)三个自动变量

​	$@：在规则的命令中，表示规则中的目标

​	$<：在规则的命令中，表示第一个依赖条件.如果将该变量应用于模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则。

​	$^：在规则的命令中，表示所有依赖条件

#### 7)模式规则

​		%.o:%.c

​				gcc -c $< -o %@

#### 8)伪目标

​	防止文件中重名导致（比如clean）致使某些无法使用，输入使生成一些伪目标（不管条件满足与否，这个目标都要被执行）

​			.PHONY:目标文件 

#### 9)注意

​	makefile会把他的文件中碰到的第一组规则当中的目标作为终极目标。---解决--->在开头指定终极目标	**ALL：目标**

​	可以在makefile末尾加上clean，在变成结束之后将某些文件清除。运行时应加上clean （-n---->预执行，检查删除对象，防止误删）而且clean无依赖关系。

### 3.系统调用

​	里面的函数性能比自己写的函数更好，但应用性差一些。能使用库函数的情况下优先使用库函数。

​	实际上使用的函数不是真正的系统调用，man查询函数信息的内容与真正的系统调用函数的程序一直，比如常用的open被视为是系统调用，但真正的系统调用函数是sys_open，这两者的具体内容方式一致的。open严谨的说法应该是系统函数，而非系统调用。

​	如下图所示，图片中的write作为通行证使printf函数进入到内核中调用驱动，驱动使内容打印显卡上。

![image-20211208115434896](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211208115434896.png)

### 4.open函数

1)函数

​	pathname路径名，flags文件描述符,会返回值

​	 mode----->打开方式（r,w,x）

​	mode_t----->八进制的整型

​	当文件不存在时，应加上打开方式权限；当仅仅是打开已有的文件时，不需要加权限。

​	int open(const char *pathname,int flags);

​	int open(const char *pathname,int flags,mode_t mode);

2)常用参数

#### 	i)flags的参数

​		O_RDONLY(只读)、O_WRONLY(只写)、O_RDWR

​		O_APPEND(追加)、O_CREAT(创建)、O_EXCL(判断文件是否存在)、O_TRUNC(截断文件大小)、O_NONBLOCK

​					创建文件时,指定文件访问权限.权限同时受umake影响,结论为:文件权限=mode&~umake

​				还需使用头文件<fcntl.h>

​	再unix中使用头文件为unistd.h,代替常规使用的stdio.h

#### 	ii)返回值

​			打开和关闭的返回值是打开文件所得到对应的  文件描述符（整数）,失败是-1.

​			以写方式打开只读文件,也会返回-1;

​			以只写方式打开目录,返回值为-1.

#### 	iii)trunc

​			trunc---->截断文件为0,(差不多是将文件清空)

#### 	iv)错误处理函数

​		与error相关

​			有时也可使用errno查看错误类型,头文件为<errno.h>.----->解读使用strerror(errno)---->头文件为<string.h>

​			char *strerror(int errno);

​						printf(“xxxx  error=%s”,strerror(errno));

​			void perror(const char *s);

​						perror(“open error”);内部是一个关于错误位置的描述。

### 5.read/wirte

​	头文件均为<fcuntl.h>、<unistd.h>

​	write和read函数常常被称为是Unbuffered I/O，指的是无用户及无缓冲区，但不保证不使用内核缓冲区。

#### 	1)read

​		读取文件直到为0时停止,当文件无法读取时会返回-1,并设置errno的值

​		ssize_t  read (int fd ,void *buf, size_t count)

​				参数:

​							fd----->文件描述符

​							buf---->存数据的缓冲区

​							count--->缓冲区大小

​				返回值:

​							成功---->读到的字节数

​							失败---->-1,并设置errno值

​							返回-1而且errno=EAGIN或EWOULBLOCK,说明不是read失败，而是read再以非阻塞的方式读一个设备文件（网络文件），并且文件无数据。

#### 2)write

​		ssize_t  write (int fd ,const void *buf, size_t count)

​				参数:

​							fd----->文件描述符

​							buf---->待写出数据的缓冲区

​							count--->实际要写出内容的大小

​				返回值:

​							成功---->写入的字节数

​							失败---->-1,并设置errno值

​		3)如果使用read和write的话，比使用fputs和fgets慢

​			可以使用strace来查看程序执行过程中的系统调用，

​		4)写入和读取过程

​			fputc函数内部也存在一个缓存区（大小为4096个字节=4K）

​			写入的操作是首先将buf内的信息从用户区写入到内核区域（电子过程），再由内核写入到磁盘上(物理过程)，内核的缓存区大小为4096个字节（4K大小）

​			预读入缓输入机制：

![image-20211210112639671](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211210112639671.png)

​			从用户到内核这个过程十分耗时。

### 	6.内核区

​	位于3G~4G的位置

​		1)内核有什么

​			PCB进程控制块本质上是一个结构体，其中最重要的是文件描述符表。

​			文件描述符表中的每一个文件描述符的本质是指向文件结构体的指针

​				struct file {

​					一定是已经使用open或fopen成功打开的文件

​				}------>文件结构体

​				要想操作这些文件就要使用文件描述符，操作系统会将除了序号之外的信息隐藏。

​				0--->stdin	  			宏定义	STDIN_FILENO				标准输入

​				1--->stdout				宏定义	STDOUT_FILENO

​				2--->stderr	 			宏定义	STDERR_FILENO

​				3--->打开的第一个文件

​				4--->打开的第二个文件（仅当3被占用时）

​				......

​				直到1023。默认使用除0、1、2之外最小的数

​	查看打开文件的个数1024

​				命令查看：ulimit -a查看open file 对应值，默认1024

​								或使用 ulimit -n 4096  修改

​									或修改系统配置文件永久修改该值。

​	2)FILE结构体

​		主要包含文件描述符、文件读写位置、IO缓冲区三部分内容。

​	![image-20211210115554691](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211210115554691.png)

### 7.阻塞和非阻塞

#### 1)可能出现阻塞的情况

​		通常情况下，读取文件是不会阻塞的，阻塞一般是在读取设备或网络时发生。

​		/dev/tty (终端文件、输入、输出)

![image-20211210120043775](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211210120043775.png)

​		从键盘读到缓冲区，在把读入的信息写到标准输出上。

​		当没有输入的时候就会发生阻塞的情况，进入持续的等待中。

#### 	2)使用非阻塞的情况

​		在read时，返回-1而且errno=EAGIN或EWOULBLOCK,说明不是read失败，而是read再以非阻塞的方式读一个设备文件（网络文件），并且文件无数据。

​		open(“/dev/tty”,O_RDWR|O_NONBLOCK)		---  设置  /dev/tty  非阻塞状态（默认为阻塞状态）

### 8.fcntl函数

​	改变一个  **已经打开的文件**  

​		int fcntl(int fd ,int cmd, . . . /*  arg  */);

​	int falgs=int fcntl( STDIN_FILENO,F_GETFL)

​		flags|=O_NONBLOCK

​		fcntl(STDIN_FILENO,F_SETFL,flags)

​		F_GETFL    获取文件状态

​		F_SETFL    更改文件状态

### 9.lseek函数

​		off_t  lseek (int fd,off_t  offset ,int  whence)

​				fd---->文件描述符。

​				offset是偏移量，off_t是矢量。

​				whence可以设置偏移的起始位置。

​					SEEK_SET  文件开始

​					SET_CUR    当前位置

​					SET_END    文件末尾

​				返回值：

​							成功：较起始位置偏移量

​							失败：-1，并设置errno

​			应用场景：  1.文件的“读”、“写”使用同一偏移位置

​								2.使用lseek获取文件大小

​								3.使用lseek拓展文件大小,想要使文件大小真正拓展，必须引起IO操作。

​			od-tcx  filename   查看文件的16进制表示方式

​			od-tcd  filename   查看文件的10进制表示方式

### 10.truncate函数

​		直接拓展文件。

​	int  truncate(const char *path,off_t length);

​	path---->文件

​	length-->需拓展的长度

​	注意：只有对文件有写的权限的时候才可以对文件进行扩展

### 11.传入参数

​	1)指针作为函数参数；

​	2)通常有const关键字修饰；

​	3)指针指向有效区域，在函数内部做读操作。

### 12.传出参数

​	1)指针作为函数参数；

​	2)在函数调用之前，指针指向的空间可以无意义，但必须有效；

​	3)在函数内部做写操作；

​	4)函数调用结束后充当函数返回值。

### 13.传入传出参数

​	1)指针作为函数参数；

​	2)在函数调用之前，指针指向的空间有实际意义；

​	3)在函数内部，先做读操作，后做写操作；

​	4)函数调用结束后，充当函数返回值。

### 14.文件存储

#### 	1)inode

​		本质为结构体，存储文件的属性信息，如：权限、类型、大小、修改时间、用户、盘块位置......也叫做文件属性管理结构，大多数的inode都存储在磁盘上

​		少量常用、近期使用的inode会被缓存到内存。

#### 	2)dentry

​			目录项，包含文件名和inode号，可以由inode号找到文件的各种信息。

​			硬链接与原文件相比只是dentry不同。

### 15.stat函数

​		获取文件属性

​	int stat(const char *path,struct stat *buf);

​	path：文件路径

​	struct stat *buf------->传出参数（存放文件属性）

​									成功：0 ；失败：-1+errno

​	lstat与stat基本一致，lstat不会穿透符号链接，而stat会穿透符号链接。

​	ls也不会穿透符号链接，catch、vim等命令会穿透符号链接。

​	获取文件大小：buf.st_size

​	获取文件类型：buf.st_mode

​	获取文件权限：buf.st_mode

### 	16.位图

​		16位

​		文件类型占据

​	后九个中三个三个的分别表示文件中的读写执行权限，再往前的三位是特殊权限位，最前面的四位用来表示文件权限类型。

### 17.link与unlink函数

#### 	1)link

​		创建硬连接的函数

​		int link(const char *oldpath , const char *newpath);

#### 	2)unlink

​		int unlink (const char *pathname);

​		删除文件的一个目录项。

​		返回值：成功返回0，失败返回-1并设置errno的值。

​		Linux删除文件的机制：不断将st nlink   -1  ，直到减到0为止。无目录相对应的文件，将会被操作系统择机释放(具体算法由系统内部调度算法决定0)。

​		我们再删除文件的时候，从某种意义上说，只是让文件具备了被释放的条件。

​		unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件不会马上被释放掉。要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉。

### 18.隐式回收

​	操作系统在进程结束运行时，所有该进程打开的文件会被关闭，申请的内存空间会被释放。

​	系统的这一特性被称之为隐式回收系统资源。

### 19.文件操作函数

#### 	1)readlink函数

​			可以读取符号链接本身,得到链接所指向的文件名。

#### 	2)rename函数

​			重命名一个文件

### 20.目录操作函数

#### 	1)getcwd函数

​			获取进程当前工作目录。

#### 	2)chdir函数

​			改变当前进程的工作目录。

### 21.文件、目录权限

​	linux中所见皆文件，故目录文件也是“文件”。其文件内容是该目录下所有子文件的目录项dentry。

​							r												w												x

文件			文件的内容可以被查看			内容可以被修改						可以产生一个进程

​					cat、more、less·····				vim······									./文件名

目录			目录可以被浏览					创建、删除、修改文件				可以被打开、进入

​						ls、tree······						mv、touch、mkdir····					cd

### 22.目录操作

​	DIR * opendir(char *name);

​	int closedir(DIR *dp);

​	struct dirent *readdir(DIR *dp);

​		struct dirent{

​			inode;

​			dname;	

​			}

### 23.exit函数

​	再循环当中常用的函数之一，作用是使得当前进程结束

​	exit（1）：非正常运行导致退出程序；

​	exit（-1）：非正常运行导致退出程序，与1类似。

​	exit（0）：正常运行程序并退出程序。

​	_exit（0）：不能输出结果，未清除I/O缓存，不打印。

## （三）P69-P95

### 1.递归遍历目录

​	1)思路及步骤

​		a.判断命令行参数获取用户要查询的目录名；		argv[1]

​				argc == 1 --->  ./

​		b.判断用户指定的是否是目录。如果是文件的话，就直接打印文件名。	stat   S_ISDIR()--->可以放到一个函数之内，便于使用。

​		c.读取目录，使用之前学到过的函数

​				opendir()

​				while(readdir()){

​					判断是否为文件的函数。如果是，就打印出来；如果是目录，就递归调用，使目录打开再读。对于打开内层文件的时候，只可以使用绝对路径，此时需要将所处位置进行拼接，可以使用strcat或者sprintf，strcat(原路径，/)；strcat(拼上/的路径名，新目录名)；或者是sprintf(新路径的代号，“%s/%s”,原路径，新目录名)。在再次调用时仍需进行判断文件是否是目录。 

​				}

​				closedir()

### 2.dup和dup2

#### 1)dup

​	dup函数为int类型，使用值为旧文件描述符，返回值为新文件描述符。

​	int dup(int oldfd);

​	dup拷贝出的文件是一个新的文件，不会对源文件造成影响。

#### 2)dup2

​	dup2(int oldfd ,int newfd);

​	其中oldfd代表的是旧文件描述符，而newfd代表的是新文件描述符。

​	当oldfd不是一个有效的文件描述符时，会导致文件的调用失败，并且newfd也不会关闭。

​	当oldfd是一个有效的文件描述符的时候，令oldfd和newfd拥有相同的值（实质上是将指向文件的指针变得相同），然后dup2()不做任何事，再返回newfd，即新的文件描述符。

​	将newfd改为STDOUT_FILENO可以将要输入到屏幕上的内容全部截止到旧文件描述符对应的文件当中。

#### 3)使用fcntl来实现dup

​	int fcntl(fd,F_BUPFD,0);当0被占用的时候，fcdntl会使用文件描述符表当中的可使用的最小文件描述符使用并返回。未被占用的时候就会返回定的那个文件描述符。

### 3.程序和进程

#### 1)概念

​	程序：只占用磁盘空间，其他的不占用。

​	进程：占用内存、CPU等等的系统资源。运行起来的程序。

#### 2)并发

​	在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕的状态，但任意时刻点上仍有只一个进程在运行。

#### 3)单道程序设计

​	所有进程一个一个排队执行，有文件堵塞，后面的文件只能等待堵塞结束。

#### 4)多到程序设计

​	计算机内存中同时存放几道相互独立的程序，在管理程序的控制之下，相互穿插运行。多到程序设计必须有硬件基础作为保证。

​	理论基础是时钟中断。系统强制让进程让出CPU资源的手段，时钟中断有硬件基础作为保障。

### 4.MMU

#### 1)虚拟内存与物理内存间的映射关系

​	MMU是虚拟内存，映射单元，在CPU内部,大小为4K。

​	使用数据段和代码段的时候，虚拟地址中的数据是无法直接使用的，需要MMU来映射到物理内存当中方可使用。

​	有两个进程的时候，就算有完全相同的两个变量（变量名、变量类型、对应的虚拟地址均相同），也是进行分区映射，互不影响。

​	当一个数组映射时，物理内存上没有一个可以容纳它的连续的部分时，MMU会将物理内存尚未使用的部分一起被这个数组映射。

​	在某个进程结束后，会释放映射到物理内存中的所有部分，以方便后续使用。

​	当虚拟内存中的部分没有数据的时候，就不会对物理内存进行映射。

​	当对内核进行映射的时候，两个或多个进程通过MMU映射到物理内存的部位相同，因为电脑只有一个操作系统，只有一个内核。

​	可以参考下图：

​	![655CF238A59533561390E618A78025F4](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/picccc655CF238A59533561390E618A78025F4.jpg)

2)设置修改内存访问级别

​	CPU对内存进行分级，在Windows下分四级，0、1、2、3；而在Linux中仅仅分两段，0、3。

​	当数据从用户空间调到内核空间之所以速度慢，是因为MMU在改变权限，但是比较慢。

### 5.PCB--进程控制块

#### 1)概念

​	是进程中内核区用来维护进程相关的信息的，在Linux中内核的进程控制块是task_struct结构体。

#### 2)位置

​	/user/src/linux-headers-3.16.0-30/include/linux/sched.h(不知道Gentos和unb的位置是不是相同的)

在该位置可以查看struct task_struct结构体定义。

结构包括：

​		进程id。系统给每个进程分配一个独特的id，在C语言中用pid t 类型表示，也就是一个非负整数。

​		进程的状态。有初始化、就绪、运行、挂起、停止等状态。

​		如图示：![Screenshot_20211216_190410_tv.danmaku.bili](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccScreenshot_20211216_190410_tv.danmaku.bili.jpg)

​		进程切换时需要保存和恢复一些CPU寄存器。（当运行终止的时候，寄存器会被释放，程序进入休眠，当程序再次获得CPU使用时，不必再次从头算起，之前的数据保存在PCB当中，从PCB当中获取并恢复数据）

​		描述虚拟地址空间的信息。（由MMU编写出的信息，PCB代为存储）

​		描述控制终端的信息。（需要与用户交涉的会存在）

​		当前工作目录位置（Current Working Directory）

​		umask掩码

​		文件描述符表，包含很多指向file结构体的指针。

​		和信号相关的信息。

​		用户id和组id。

​		会话（Session）和进程组。

​		进程可以使用的资源上限。

### 6.环境变量

​	echo $后缀

​		PATH		寻找可执行文件

​		SHELL				解析命令

​		TERM				终端（图形界面下通常为xterm）

​		LANG				语言和locale,决定字符编码以及时间、货币等信息的显示格式（zh_CN为简体中文，UTF-8格式存储）

​		HOME				宿主目录

​	env可查询全部的环境变量

### 7.进程控制

#### 1)fork函数

​	pid_t fork(void)	前缀要求以#include<unistd.h>

​	用于创建一个子进程。

​	返回值：成功的话父进程返回子进程id，子进程返回0，各自继续运行，失败返回-1

​	子进程与父进程完全一致，但子进程当中父进程在fork之前用过的函数不再使用，只会执行之后的程序。

#### 2)getpid函数

​	pid_t getpid(void)  获取进程id

​	pid_t getppid(void)  获取父进程id

​	创建的文件的父进程是bash（也可以是其他的操作系统），因为是操作系统帮忙创建和调用的。

#### 3)注意

​	当父进程与子进程同时运行时，就会争夺CPU，而且有时会因为父进程结果过早导致还未打印完毕就退出程序，将结果之一打印在命令行中。使父进程最后打出，而且令子进程按照顺序输出，可以使用sleep()函数。分别挂起不等的时间。

### 8.进程共享

​	父子进程在fork之后的相同与相异。

​		刚fork之后：

​			相同之处：date段、text段、栈、堆、环境变量、全局变量、用户id、宿主目录位置、进程工作目录位置、信号处理方式（0~3G区间部分）

​			不同之处：1.进程ID	2.fork返回值	3.父进程ID	4.运行时间	5.闹钟(定时器)	6.未决信号集

​		父子进程并不共享全局变量，父子进程间遵循对全局变量的“读取时共享写时复制”的原则。

​		父子进程共享：文件描述符（打开文件的结构体）、mmap建立的映射区（进程间通信详解）

​		fork之后父进程先执行还是子进程先执行是不确定的。这件事是取决于内核所使用的调度算法。

### 9.父子进程gdb调试

​	要跟踪进程需要用到以下命令：（未设置的话默认跟踪父进程）

​		set follow-fork-mode child		命令设置gdb在fork之后跟踪子进程

​		set follow-fork-mode parent  	设置跟踪父进程

​	一定要在在gdb内调用到fork之前使用方可。

#### 	注：

​			本处还有很多模糊之处，对于视频中的呢内容感到疑惑，对实际运行的顺序看不大懂。

### 10.exec函数族

​	属于库函数系列。

​	成功无返回，失败返回-1，并且设置errno。

​	执行父子程序时，可以用exec函数使子程序执行不同于父程序的一个新程序。

​	在调用新的程序的时候，该进程的代码空间和数据完全被新程序替换，从新程序的启动历程开始执行。调用exec并不会创建新进程，所以调用exec前后进程的id(仍然为子进程id)并未改变。

​	exec函数的种类有：

​		其中的	...	代表参数的数量，但一般在不知道参数有多少个的时候，应该将其填为NULL。（意味一直执行到参数结束为止）

​		int execl(const char *path,const char *arg,...);

​			可以使用自己编写的程序，也可以使用系统程序(如要使用  ls  输入  /bin/ls  )，也是要讲path输入两次，但第二次输入的时候可以仅写名字不写路径，可以在其后指定要传入的参数。与execlp类似。

​		int execlp(const char *file,const char *arg);				

​			加载一个进程，借助PATA环境变量。

​			参数1：要加载的子程序名字。需借助PATA环境变量来使用，当PATA中所有目录搜索后没有参数1 则返回出错。

​			通常用于调用系统程序。如：ls,date,cp,cat等等。

​			在使用的时候，第一部分是命令（file），但在第二部分(arg)中，是从argv[0]开始记录的，所以要将第一部分的内容重新输入一遍，在具体的参数前面。

​		int execle(const char *path,const char *arg,...,char *const envp[ ]);

​		int execv(const char *path,char *const argv[ ]);

​		int execvp(const char *file,char *const argv[ ]);

​			相对于execl和execlp来说，将本写在函数内部的参数写成一个函数再写入到函数当中。

​			加载一个程序，使用自定义变量env

​			参数形式不同，但是原理相同。

​			变参形式：(1)	...	(2)	argv[ ]

​			变参终止条件：(1)NULL结尾；(2)固参一致。

​		int eecve(const char *path,char *const argv[ ],char *const envp[ ]);

​	exec函数族的一般规律：

​		exec函数一旦调用成功就立即执行新程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()。无需if判断。

​		l(list)						命令行参数列表

​		p(path)					搜索file时使用path变量

​		v(vector)				  使用命令行参数数组

​		e(environment)		使用环境变量数组，不使用进程原有的环境变量，设置加载新程序运行时的环境变量。

​		事实上只有execve是真正的系统调用，其他五个函数最终都调用execve，所以execve在man手册第2节，其它函数在第3节。这些函数的关系为：

![image-20211219161319661](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211219161319661.png)

### 	11.孤儿进程

​	父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，成为init成为init进程领养孤儿进程。

​	“收养”的目的是为了回收进程。

### 12.僵尸进程

​	进程中止，父进程尚未回收，子进程残留资源（PCB）存放与内核当中，变成了僵尸进程。

​	僵尸进程无法靠kill命令清除。因为kill命令是用来中止进程的，而僵尸进程已经终止。

​	可以通过将其父进程kill，令该僵尸进程被init函数“收养”，从而将其回收。

### 13.ps ajx | more

​	使用之后和ps aux不一样，会出现PPID（父进程id)，PID（自己的id），PGID(进程组id)，SID等等。

### 14.wait函数

​	一个进程在终止的时候会关闭所有的文件描述符，释放用户空间分配的内存，但它的PCB还保留着，内核在其中还保留着一些信息，如果是正常终止则会保存着退出的状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以使用wait或者是waitpid获取这些信息，然后彻底清除这个进程。如果是要在shell中产看可以使用$?来查看，本质上是在调用wait或waitpid函数。

​	父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：

​		a.阻塞等待子进程退出（当子进程未终止的时候）

​		b.回收子进程残留资源

​		c.获取子进程结束状态（退出原因）

​	pit_t wait(int *status);成功：清理掉的子进程ID；失败返回-1。

​	也可以在初始可以定义pid_t wpid;int status;wpid=wait(&status);

​		如果不需要获取子进程终止原因的话，将上面的原先该使用的wait(&status)改变为wait(NULL)j即可。

​		如果要获取更多关于子进程的详细信息，就需要使用到关于wait的宏函数（用man来查看并找到宏函数）。

​		常用到的几个宏函数：（一般常用的是前两个）

​			WIFEXITRD(status)	------>非0表示进程正常结束

​				为真时一般使用WEXITSTATUS(status)  ---->  获取进程退出状态(exit的参数)

​			WIFSIGNALED(status)  ---->非0 表示进程异常终止

​				为真时一般使用WTERMSIG(status)  ---->取得进程中止的那个信号的编号（如果用 kill -9 进程id来杀死进程的话，返回的编号为9）

​			WIFSTOPPED(status)  ---->非0表示进程处于暂停状态。

​				为真时一般使用WSTOPSIG(status)  ---->取得使程序暂停的那个信号的编号

​				WIFCONTINUED(status)  ---->进程暂停后已经继续运行。

### *信号与异常终止

​	学到这里只需要知道程序的异常终止全部都是因为信号。

​	信号可以使用	kill  -l  来查看不同信号代表的错误类型。

### 15.waitpid函数

​		pid_t waitpid (pid_t pid , int *status,int options);

​		可以指定进程的pid去回收程序，后面的status用法和wait一致，

​		要回收多个子进程，就需要使用while，因为waitpid每次使用只能回收一个子进程

​		一般有两种方式来去回收子进程，一种是让父进程sleep短暂的时间，还有一种是将waitpid中的WNOHANG换为0即从非阻塞换为阻塞。

​		waitpid(-1,&status,0)=wait(&status)		

​		option一般有一个参数，在回收过程中如果子进程陷入死循环的话，父进程就会也无法终止，而这时，waitpid可以打破这个僵局，它可以指定第三个参数的值。WNOHANG意味不挂起，在陷入到上面那种情况的时候，waitpid会直接返回，返回值：  >0：表示成功回收的子进程pid；	0：函数调用时，参3指定了WNOHANG，并且，没有子进程结束；	-1：失败，errno。

​		参数pid：

​			>0	回收指定子进程ID

​			-1	回收任意子进程（相当于wait）

​			0	 回收和当前调用waitpid一个组的所有子进程（组内的子进程可以通过系统调用被分出去）

​			< -1 	回收指定进程组内的任意子进程（对应的相反数的进程组）

### 16.对于wait和waitpid的注意点

​	一个wait或者是waitpid函数调用，都是一次只能回收一个子进程、当有多个时会随机回收。

## （四）P96-P132

### 1.进程间通信(IPC)

#### 	1)原理

​			两个进程有相同的内核区，利用一块内核的缓冲区(大小为4096，也就是buf)

#### 	2)现在常用的一些通信方式：

​		管道通信(使用最简单，但因为只能运用于有关系的进程之间，就局限了使用)、信号(开销最小，携带的数据有限，能够表现的数据比较单一，但由于占用的系统资源比较少，速度相对快)、共享映射区(可以用于一些没有血缘关系的区域)、本地套接字(最稳定，但是实现的复杂度比较高)

#### 	3)管道

​		用于有关系的进程之间，一般是父子进程之间

​		只是占用内存区，不是真正的文件

​		调用pipe()函数建立

​		特质：

​				i)伪文件（实为内核缓冲区）

​				ii)有两个文件描述符引用，一个表示读端，一个表示写端

​				iii)数据从管道的写端流入，读端流出

​		原理：内核使用环形队列机制，借助内核缓冲区(4k)实现的

​		局限性：

​				i.数据不能自己写自己读

​				ii.管道中的数据不可以被反复读取，因为管道是利用队列来实现的

​				iii.通信方式为双向半双工通信(简单来说类似于对讲机，当说的时候无法听，当听的时候无法说，无法同时双向流动)，但数据只会在单方向上流动。通信方式的其他类型：单工通信(有指定的发送方与接收方)、双向全双工通信(可以双向同时发送或者接收信息)

​				iv.只能在有公共祖先的进程间使用管道

#### 	4)pipe函数

​		pipr(int pipefd[2])		两端(读与写)----->pipefd[0]:读端	pipefd[1]：写端

​		使用该函数可以创建并打开一个管道。

​		返回值：成功为0，失败为-1 errno

​		先pipe，再fork。

#### 	5)管道的读写行为

##### 		i.读管道

​			当管道中有数据的时候，read会返回实际读到的字节数

​			管道中无数据

​					写端被完全关闭的时候，read返回0；

​					写端未被完全关闭，read会阻塞，等待数据的写入，而让出CPU

##### 		ii.写管道

​			当管道被完全关闭，进程会异常终止（也可以捕捉SIGPIPE信号(是使进程中止的信号，使进程不终止）

​			当管道未完全关闭

​					管道已满，read堵塞

​					管道未满，write会将数据写入，并返回实际写入的字节数

​		当父子进程或成兄弟进程间输入输出时，要用到dup2()、execlp()等的函数，可以关闭一方的读端和另一方的写端，分开情况来写程序。也可以有多个读入或者读出，

​		管道的大小默认为4KB。

​		可以使用ulimite -a命令来实现查看对应内核缓冲区的大小。也可以使用fpathconf函数来查看，但是要引入头文件<unistd.h>。long fpathconf(int fd , int name)。成功返回管道的大小，失败返回-1可设置errno。name可取的较多，查管道的话使用_PC_PIPE_BUF

#### 		6)管道的优劣

​			优点：简单

​			缺点：只能单向通信，双向的话需要建立两个管道；只能用于有关系的进程间通信，可被fifo有名管道解决这个问题。

#### 		7)FIFO

​			常被认为是，命名管道，使无关系的进程也可以进行通信。

​			创建方式：用mkfifo命令或者使用库函数int mkfifo(const char*pathname,mode_t mode);成功为1，失败为0。

​			使用mkfifo创建一个FIFO后可以用open打开，常见的I/O函数都可用于fifo，如：close、read、write等。函数的头文件为#include<sys/stat.h>和#include<types.h>（包含于#include<unistd.h>）

#### 8)文件进程间通信

​		不论是否有血缘关系，都可以进程文件间的通信，由一个持续写入，一个持续读取。但是在使用的时候有先后顺序，如果顺序错误是看不见想看的结果的。

#### 9)存储映射I/O

##### 	i.mmap函数

​		创建共享内存映射区

​		void *mmap(void *addr,size_t length,int prot,int flags,int fd,off_toffset);

​	头文件#include<sys/mman.h>

​	返回：成功：返回创建的映射区的首函数			失败：MAP_FAILED的宏并且设置errno

​	参数：

​			addr：创建映射区的首地址，由linux内核指定。使用时，直接传递NULL，使系统自动分配。

​			length：共享映射区的内存大小(正常情况下是小于等于文件大小，常用文件大小)

​			prot：映射区权限(共享内存映射区的读写属性 )PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE

​			flags：标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)，标注共享内存的共享属性。

​						MAP_SHARED：会将映射区所做的操作反映到物理设备上（如磁盘等）

​						MAP_PRIVATE ：映射区所做的修改不会反映到物理设备(更像私有的)

​				fd：用于创建共享内存映射区的文件描述符。

​				offset：默认为0，表示映射文件全部偏移位置的取值，只能是4k的整数倍。

##### 	 	ii.munmap函数

​				int munmap(void *addr,size_t length)

##### 		iii.mmap函数的使用事项

​	创建映射区是依赖与一个文件而形成的，可以使用unlink、close来将文件删除掉。

​		1.用于创建映射区的文件大小为0，而实际指定非0大小创建映射区，会出现“总线错误”。

​		2.用于创建映射区的文件大小为0，而实际指定创建的映射区大小同样为0，会出现“无效参数”的错误。

​		3.用于创建映射区的文件为只读，而实际映射区为读写属性，会出现“无效参数”的错误

​		4.mmap建立映射区的时候必须要有读的权限，当访问权限指定为”共享“(MAP_SHARED)的时候mmap的读写权限<=文件的open权限)

​		5.文件描述符fd，在mmap创建映射区完成即可关闭，后续访问文件，用地址访问。

​		6.offset必须是4096的整数倍

​		7.对申请的内存，不能越界访问。

​		8.mmap用于释放的地址，闭学式mmap申请的区域

​		9.映射区访问权限“私有”MAP_PRIVATE,对内存所做的修改，只在内存有效，不会反映到物理磁盘上。

​		10.映射区访问权限为私有的时候，只需要open文件的时候有读权限，用于创建映射区即可

##### 	iv.父子间mmap进程通信

​		权限应该是share,而不是private。

​		先创建映射区，然后在进行fork操作。

​		原本的进程在内存申请了一个区域来存放映射区，由一个指针来指向这个地方，当fork之后，父进程与子进程都拥有这个指向映射区的指针，都可以访问并修改映射区。

##### v.无血缘关系的mmap

​		是通过文件进行读取的，两个文件打开同一个文件，这个文件应该是share的，原来的文件是将该文件内的东西写入到中介的文件中，可以通过mencpy函数来进行复制，在另一个文件进行读操作，就可以打印出来。

​		mmap可以重复读取，然而fifo只能一次读取。

#### 10)匿名映射

​		添加使用flags参数MAP_ANONYMOUS或者是MAP_ANON

​		fd传 -1 。利用 -1 进行占位。

​		只能用于血缘关系间进程通信。

​	但是如果去使用老版的类Linux操作系统，没有MAP_ANON的操作选项，就需要去其他的地方获取（/dev/zero可以读取任意大小的文件，但读取到的内容全部都为空洞，即'/0'		相对应的/dev/null可以吞噬文件，写多少吃多少）

​	

### 2.memcpy函数

​	int memcpy(void *dest,const void *src,size_t n);

​		功能从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中

​		这里的“p”是一个指针，指的是

​		size_t，它是一种“整型”类型，里面保存的是一个整数，就像int, long那样。这种整数用来记录一个大小(size)。size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。

​		n 可以决定整个函数在使用的时候复制多长的字符串。

### 3.信号

#### 	1)特点

​		简单，不能携带大量信息，满足条件才发送

#### 	2)特质

​		信号是软件层面的“中断”，一旦产生信号，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束后在继续执行指令。

​		所有信号的产生、发送及处理都是由【内核】完成的。

#### 	3)与信号相关的时间和状态

##### 		i.产生信号

​		按键产生：Ctrl+C----->2)SIGINT(终止/中断)、Ctrl+z------>20}SIGTSTP(暂停/停止)、Ctrl+\------>3}SIGQUIT(退出)

​		系统调用产生：kill,raise,abort

​		软件条件产生：如定时器alarm

​		硬件异常产生：如非法访问内存(段错误)，除0(浮点数以外)、内存对齐出错(总线错误)

​		命令产生：比如kill命令

##### 		ii.递达

​			递送并且到达进程

##### 		iii.未决

​			产生和递达之间的状态，主要由于阻塞(屏蔽)该状态

##### 		iv.信号的处理方式

​			执行默认动作

​			忽略(丢弃)

​			捕捉(调用户处理函数)

​		linux内核的进程控制块PCB是一个结构体，task_struct，除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。未决信号集的本质是位图。

##### 		v.阻塞信号集

​			或者说是信号屏蔽字，将某些信号加入集合，对他们设置屏蔽，当屏蔽X信号后，在收到该信号，该信号的处理将推后(解除屏蔽后)。

​			可以被人为改变，通过信号集的操作即可。

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220303104816037.png" alt="image-20220303104816037" style="zoom:150%;" />

##### 		vi.未决信号集

​			1.信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态，当信号被处理，对应位翻转为0，这一时刻往往非常短暂。

​			2.信号产生后由于某种原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集，在屏蔽解除前，信号一直处于未决状态。

​			不会被直接更改，只会因阻塞信号集的改变而改变。

##### 	vii.信号的编号

​			可以使用kill -l来查看信号的编号

​			![image-20220223200942357](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220223200942357.png)

​	1~31为常规信号或者说是普通信号。都有默认事件和处理动作。		

​	34及之后的被称为实时信号，并没有默认事件，且一般用于硬件开发。

##### 		viii.信号4要素

​			与变量三要素(变量类型、变量名和变量值)类似，变量的四要素为编号、名称、事件、默认处理动作。

​			在使用信号之前应确定信号的四要素。

​			使用man 7 signal  来查看，会列出使用到的信号。

​			有些信号有三个对应的值，是因为在不同的操作系统之下同一信号对应的值可能是不同的。

​			信号的产生情况：

​			1~ 3和7 ~15，17，19为比较常用的几个信号。

![image-20220223202953104](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220223202953104.png)

![image-20220223203415166](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220223203415166.png)

![image-20220223203606987](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220223203606987.png)

​		注意：9号和19号是不允许忽略和捕捉的，只能执行默认动作，甚至不能将其设置为阻塞。

​				  另外，只有每个信号对应的时间发生了，该信号才会被递达(但不一定递达)，不能乱发信号。

### 4.kill函数/命令

​	kill命令产生信号：kill -SIGKILL pid

​	kill函数：给指定进程发送指定信号(但不一定杀死)

​			int kill(pid_t pid ,int sig);			头文件：#include<signal.h>	#include<sys/types.h>

​			返回值：成功0，失败-1(ID非法，信号非法，普通用户杀init进程等权级问题)，并设置errno。

​			pid>0，发送信号给指定进程。

​			pid=0，发送信号给调用kill函数进程属于同一进程组的所有进程。

​			pid<-1，取|pid|发送给对应进程组。

​			pid=-1，发送给进程有权限发送的系统中的所有进程。

​		进程组的ID和进程组长的ID是相同的，有时也是父进程。

​		权限保护：root用户可以发送信号给任何用户，但是普通用户无权向系统用户发送信号。kill -9 是无法对root用户的pid进行使用的。

​		普通用户的基本规则：发送者实际或有效用户ID==接收者实际或有效用户ID。

​		普通用户也不能终止其他普通用户的进程，只能终止自己的。

​	其他发信号的函数：

​				int raise(int sig);

​				void abort(void);

### 5.alarm函数

​		可以设置定时器(闹钟)，制定second之后，内核会给当前进程发送14)SIGALRM信号，进程收到该信号，默认动作为终止。

​		每个进程有且仅有唯一的定时器。

​		使用alarm(0)可以取消定时器，返回旧闹钟余下秒数。

​		unsigned int akarm(unsigned seconds);

​		返回0或者剩余的秒数，无失败。

​		定时与进程状态无关(自然定时法)，就绪，运行，挂起(阻塞、暂停)，终止，僵尸……无论进程处于何种状态下，alarm都计时。

​		time加在使用文件之前，可以查看文件的时间(real--->实际执行的时间，user--->运行在用户控件的时间，sys--->运行在内核中所消耗的时间)。

​		程序实际执行的时间=系统时间+用户时间+等待时间。

​		程序运行的瓶颈在于IO，优化程序应该首先优化IO。

### 6.setitimer函数

​	设置定时器(闹钟)，可以代替alarm函数，精确到微秒，可以实现周期定时。

​	int setitimer(int which , const struct itimerval *new_value , struct itimerval *old_value);

​	参数：which：指定定时方式

​				1)自然定时：ITIMER_REAL--->14)SIGVTALRM								计算自然时间

​				2)虚拟空间计时(用户空间)：ITIMER_VIRTUAL--->26)SIGVTALRM  只计算进程占cpu的时间

​				3)运行时间计时(用户+内核)：ITIMER_PROF--->27)SIGPROF		  计算占用cpu及执行系统调用的时间 

​			返回值：成功为0，失败为-1，且设置errno。

​			new_value：定时秒数。

​			old_value：传出参数，上次定时剩余的时间。

​			类型：struc itimerval{

​								struct timeval{

​										time_t 	tv_sec					/* seconds */

​										suseconds_t	tv_usec;		/* microsecond */

​								}it_interval;		//it_interval是用来设定两次定时任务之间间隔的时间

​								struct timeval{

​										time_t 	tv_sec					/* seconds */

​										suseconds_t	tv_usec;		/* microsecond */

​								}it_value;			//it_value用于设置定时的时长

​						}	

​						使用时要定义多个值，前两个为间隔时长，后两个为第一次触发的时长。

## （五）P133~P184

### 1.信号集设定

​		#include<signal.h>

​		int sigemptyset(sigset_t *set);								//设置全部的信号集位置为0

​		int sigfillset(sigset_t *set);									  //设置全部的信号集位置为1

​		int sigaddset(sigset_t *set,int signum);				  //把某一个信号添加到某个位置

​		int sigdelset(sigset_t *set,int signum);					//把某个信号从信号集中移除出去

​		int sigisnumber(const sigset_t *set , int signum);	//查看某一个信号是否在信号集当中

​			在返回1，不在返回0。

​		int sigprocmask(int how, const sigset_t *set,sigset_t *oldset);

​			参数取值：

​					how:SIG_BLOCK------->阻塞(或者称为屏蔽)(操作相当于两个set进行位或操作)mask=mask|set

​							SIG_UNBLOCK--->解除阻塞(将set取反后和oldset进行位与)				mask=mask&~set

​							SIG_SETMASK--->set表示用于替代原始屏蔽集的新屏蔽集，相当于mask=set

​		int sigpending(sigset_t *set);可以将读取当前进程的**未决信号集**。set为传出参数

​			注：除sigisnumber函数外，其他的函数返回值均为成功返回0，失败返回-1并设置errno.

​			阻塞信号集可以屏蔽一些信号使其无法生效，而无法对9号和19号信号进行屏蔽操作。

​			Ctrl+D是往终端内写入一个EOF，但不是一个信号。

### 2.信号捕捉函数

#### 		注意

​		signal函数和sigaction函数都不具备直接捕捉函数的功能，均为**注册**一个捕捉函数的函数。

#### 		1)signal函数

​				用于**注册**一个信号捕捉函数

​				typedef void (*sighandler_t)(int);			//void ( *sighandler_t)(int)是一个函数指针

​		这个内容不太清楚	//( *sighandler_t)是一个指向返回值为空，参数为整形的函数的普通指针变量。

​				sighandler_t signal(int signum,sighandler_t handler);

​				这个函数是由ANSI定义的，因为历史的原因使得其在不同的Unix版本和不同的Linux版本当中可能有着不同的行为。尽量避免使用，最好使用sigaction函数。

​				void(*signal(int signum,void ( *sighandler_t)(int)))(int);

#### 		2)sigaction函数

​			修改信号处理动作(通常在Linux用其来**注册**一个信号的捕捉函数)

​			int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);

​					返回值：成功返回0，失败返回-1并设置errno。

​					参数：

​								act：传入参数，新的处理方式

​								oldact：传出参数，旧的处理方式

​					//看到了P137的1"30'处



​	























































# typora快捷键操作

## 一：菜单栏

- 文件：alt+F
- 编辑：alt+E
- 段落：alt+P
- 格式：alt+O
- 视图：alt+V
- 主题：alt+T
- 帮助：alt+H

## 二：文件

- 新建：Ctrl+N
- 新建窗口：Ctrl+Shift+N
- 打开：Ctrl+O
- 快速打开：Ctrl+P
- 保存：Ctrl+S
- 另存为：Ctrl+Shift+S
- 偏好：Ctrl+,
- 关闭：Ctrl+W

## 三：编辑

- 撤销：Ctrl+Z
- 重做：Ctrl+Y
- 剪切：Ctrl+X
- 复制：Ctrl+C
- 粘贴：Ctrl+V
- 复制为MarkDown：Ctrl+Shift+C
- 粘贴为纯文本：Ctrl+Shift+V
- 全选：Ctrl+A
- 选中当前行/句：Ctrl+L
- 选中当前格式文本：Ctrl+E
- 选中当前词：Ctrl+D
- 跳转到文首：Ctrl+Home
- 跳转到所选内容：Ctrl+J
- 跳转到文末：Ctrl+End
- 查找：Ctrl+F
- 查找下一个：F3
- 查找上一个：Shift+F3
- 替换：Ctrl+H

## 四：段落

- 标题：Ctrl+1/2/3/4/5
- 段落：Ctrl+0
- 增大标题级别：Ctrl+=
- 减少标题级别：Ctrl±
- 表格：Ctrl+T
- 代码块：Ctrl+Shift+K
- 公式块：Ctrl+Shift+M
- 引用：Ctrl+Shift+Q
- 有序列表：Ctrl+Shift+[
- 无序列表：Ctrl+Shift+]
- 增加缩进：Ctrl+]
- 减少缩进：Ctrl+[

## 五：格式

- 加粗：Ctrl+B
- 斜体：Ctrl+I
- 下划线：Ctrl+U
- 代码：Ctrl+Shift+`
- 删除线：Alt+Shift+5
- 超链接：Ctrl+K
- 图像：Ctrl+Shift+I
- 清除样式：Ctrl+

## 六：视图

- 显示隐藏侧边栏：Ctrl+Shift+L
- 大纲视图：Ctrl+Shift+1
- 文档列表视图：Ctrl+Shift+2
- 文件树视图：Ctrl+Shift+3
- 源代码模式：Ctrl+/
- 专注模式：F8
- 打字机模式：F9
- 切换全屏：F11
- 实际大小：Ctrl+Shift+0
- 放大：Ctrl+Shift+=
- 缩小：Ctrl+Shift±
- 应用内窗口切换：Ctrl+Tab
- 打开DevTools：Shift+F12

## 七：其他特殊用法

1、按一下回车，取消之前的有序无序标志





# Git简介 

## git简介

### 版本控制

版本控制是一种`记录一个或若干文件内容变化`，以便将来查阅特定版本修订情况的系统。 

是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，

方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 

#### 实现跨区域多人协同开发

追踪和记载一个或者多个文件的历史记录 

组织和保护你的源代码和文档 

统计工作量 

并行开发、提高开发效率 跟踪记录整个软件的开发过程 

减轻开发人员的负担，节省时间，同时降低人为错误

`是一种用于管理多人协同开发项目的技术`

------

主流的版本控制器有如下这些：

Git 

SVN（Subversion）

CVS（Concurrent Versions System）

VSS（Micorosoft Visual SourceSafe）

TFS（Team Foundation Server）

Visual Studio Online 

版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、 Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault）

现在 影响力最大且使用最广泛的是Git与SVN

#### 本地版本控制系统

本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。

其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 

RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）

通过应用所有的补丁，可以重新计算出各个版本的文件内容。

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116165833398.png" alt="image-20220116165833398" style="zoom:33%;" />

#### 集中化的版本控制系统

集中化的版本控制系统 （Centralized Version Control Systems，简称 CVCS）这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。

> 服务器崩了 所有的客户端都不能正常运行

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116165847340.png" alt="image-20220116165847340" style="zoom:33%;" />

#### 分布式版本控制系统

分布式版本控制系统（Distributed Version Control System，简称 DVCS）在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像 下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像 出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。



<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116215445452.png" alt="image-20220116215445451" style="zoom:33%;" />

### 发展历史

2005年开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束

他们收回了 Linux 内核社区 免费使用 BitKeeper 的权力。 

这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 

他们对新的系统制订了若干目标：

 • 速度

 • 简单的设计 

• 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 

• 完全分布式 

• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）

 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快， 极其适合管理大项目，有着令人难以置信的非线性分支管理系统

### 特点

- 直接记录快照，而非差异比较

  在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

   Git 对待 数据更像是一个 快照流。

- 近乎所有操作都是本地执行

  因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 效率比较高 与集中式相比

- Git 保证完整性

  Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 

  Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组 成的字符串，基于 Git 中文件的内容或目录结构计算出来。 

  SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 -》绝对唯一 

  Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。

- Git 一般只添加数据

  一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。

  

### 工作区域

Git本地有三个工作区域：

`工作目录`（Working Directory）

`暂存区`(Stage/Index)

`资源库`(Repository 或Git Directory)。

如果在加上`远程的git仓库`(Remote Directory) / GITHUB GITEE

就可以分为四个工作区域。

文件在这四个区域之间的转换关系如下：

Workspace：工作区，就是你平时存放项目代码的地方

Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 

Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。

其中HEAD(头指针）指向最新放入仓库的版本 

Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据 交换

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116171035317.png" alt="image-20220116171035317" style="zoom:50%;" />

### 工作流程

git的工作流程一般是这样的： 

１、在工作目录中添加、修改文件；

 ２、将需要进行版本管理的文件放入暂存区域； 

３、将暂存区域的文件提交到git仓库。

 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)

• 已修改表示修改了文件，但还没保存到数据库中。

 • 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。

 • 已提交表示数据已经安全地保存在本地数据库中。

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116171653855.png" alt="image-20220116171653855" style="zoom:50%;" />

### 命令行/GUI操作

> MacOS 终端（Terminal）

> Windows 命令窗口（Command Prompt）或 PowerShell

### 安装GIT

####  MACOS

 最简单的方法是安装 Xcode Command Line Tools。 

Mavericks （10.9） 或 更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。bash

> $ git --version 

如果没有安装过命令行开发者工具，将会提示你安装。

#### WINDOWS

打开 git官网 https://git-scm.com/，

下载git对应操作系统的版本。 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows

安装成功后在开始菜单中会有Git项，菜单下有3个程序： 

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117101850809.png" alt="image-20220117101850809" style="zoom:50%;" />

Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 

Git CMD：Windows风格的命令行 

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 BASH

### 首次配置

安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。

提交代码 你是谁

 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：

```bash
git config --global user.name "John Doe" 

git config --global user.email johndoe@example.com 
```

再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事 情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 很多 GUI 工具都会在第一次运行时帮助你配置这些信息。

查看配置

```bash
git config -l
```

### 生成/添加SSH公钥

Gitee 提供了基于SSH协议的Git服务，在使用SSH协议访问仓库之前，需要先配置好账户/仓库的SSH公钥。

你可以按如下命令来生成 sshkey:

```
ssh-keygen -t ed25519 -C "xxxxx@xxxxx.com"  
# Generating public/private ed25519 key pair...
```

> 注意：这里的 `xxxxx@xxxxx.com` 只是生成的 sshkey 的名称，并不约束或要求具体命名为某个邮箱。
> 现网的大部分教程均讲解的使用邮箱生成，其一开始的初衷仅仅是为了便于辨识所以使用了邮箱。

按照提示完成三次回车，即可生成 ssh key。通过查看 `~/.ssh/id_ed25519.pub` 文件内容，获取到你的 public key

```
cat ~/.ssh/id_ed25519.pub
# ssh-ed25519 AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....
```

![SSH生成](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/picccc165113_8e58f0e1_551147.png)

![输入图片说明](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/picccc165455_ec7dbd09_551147.png)

复制生成后的 ssh key，通过仓库主页 **「管理」->「部署公钥管理」->「添加部署公钥」** ，添加生成的 public key 添加到仓库中。

![添加部署公钥](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/picccc233212_29a62378_551147.png)

添加后，在终端（Terminal）中输入

```
ssh -T git@gitee.com
```

首次使用需要确认并添加主机到本机SSH可信列表。若返回 `Hi XXX! You've successfully authenticated, but Gitee.com does not provide shell access.` 内容，则证明添加成功。

![SSH添加提示](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/picccc170837_4c5ef029_551147.png)

添加成功后，就可以使用SSH协议对仓库进行操作了。

## GIT基础

> 掌握git的基础命令 

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116172811814.png" alt="image-20220116172811814" style="zoom:50%;" />

### 获取GIT仓库 放你代码的地方

通常有两种获取 Git 项目仓库的方式： 

1. 将尚未进行版本控制的本地目录转换为 Git 仓库； 
2. 从其它服务器 克隆 一个已存在的 Git 仓库。 

两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。

##### 在已存在目录中初始化仓库

使用命令 cd 到目标文件夹

然后使用命令

```bash
git init
```

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116173249082.png" alt="image-20220116173249082" style="zoom:50%;" />

该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。

如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制

你应该开始追踪这些文件并进行初始提交。 

可以通过 git add 命令来指定所需的文件来进行追踪，

然后执行 git commit ： 

$ git add *.c 

$ git add LICENSE 

$ git commit -m 'initial project version' 

 现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。



添加当前目录下的所有文件到暂存区：

```bash
git add .
```

##### 克隆现有的仓库

克隆仓库的命令是 git clone  

比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：

```bash
 git clone https://github.com/libgit2/libgit2 
```

这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 

如果你进入到这个新建的 libgit2 文 件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。

### 操作GIT仓库

工作区域：修改了

git add 进行追踪

暂存区域 

git commit 

本地仓库 

#### 检查文件状态

```bash
git status
```

#### 跟踪文件至暂存区/暂存已经修改的文件

```bash
git add
```

可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 

将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 

#### 忽略文件 

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。



 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。

文件 .gitignore 的格式规范如下： • 所有空行或者以 # 开头的行都会被 Git 忽略。 

• 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 

• 匹配模式可以以（/）开头防止递归。 • 匹配模式可以以（/）结尾指定目录。

 • 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配 任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只 匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配 （比如 [0-9] 表示匹配所有 0 到 9 的数字）。 

```
使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以 匹配 a/z 、 a/b/z 或 a/b/c/z 等。
```

```
# 忽略所有的 .a 文件
*.a
# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a
# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO
# 忽略任何目录下名为 build 的文件夹
build/
# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

#### 查看更新部分

```bash
git diff
```

此命令比较的是工作目录中当前文件(工作区域）和暂存区域(git add)快照之间的差异。 

也就是修改之后还没有暂存起来的变化内容。 

若要查看已暂存的将要添加到下次提交里的内容，可以用 

git diff --staged 

命令。 

这条命令将比对已暂存文件与最后一次提交的文件差异

#### 提交更新 

现在的暂存区已经准备就绪，可以提交了。

 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过，否则提交的时候不会记录这些尚未暂存的变化。 

这些已修改但未暂存的文件只会保留在本地磁盘。 所 以每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit

```bash
git commit
```

另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示：

```bash
git commit -m "helloGit"
```

#### 跳过使用暂存区域

尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 

Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存 起来一并提交，从而跳过 git add 步骤

```bash
git commit -a
```

#### 移除文件

```bash
git rm
```

下一次提交时，该文件就不再纳入版本管理了。如果要删除之前修改过或已经放到暂存区的文件，则必须使用 强制删除选项 -f（译注：即 force 的首字母）。 

另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录 中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 

为达到这一目的，使用 --cached 选项： 

```bash
git rm --cached 文件名
```

也可以使用glob模式   .gitignore 

#### 文件改名/移动文件

```bash
git mv file_from file_to
```

#### 查看提交历史

> 重点

```bash
git log
```

#### 撤销重新提交

```bash
git commit --amend
```

这个命令会将暂存区中的文件提交。

 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。

 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。

 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： 

$ git commit -m 'initial commit' 

$ git add forgotten_file

 $ git commit --amend 

最终你只会有一个提交——第二次提交将代替第一次提交的结果。



#### 取消暂存文件

```bash
git reset HEAD <file>
```

#### 查看远程仓库

```bash
 git remote 
```

它会列出你指定的每一个远程服务器 的简写

指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。

#### 添加远程仓库

```bash
git clone <url> /  git remote add <shortname> <url>
```

#### 从远程仓库抓取与拉取

```bash
git fetch <remote>
```

git pull

你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。

如果你的当前分支设置了跟踪远程分支， 那么可以用 git pull 命令 来自动抓取后 合并该远程分支到当前分支。

默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。

 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。

![image-20220117195610900](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117195610900.png)

#### 推送到远程仓库

```bash
git push <remote> <branch>
```

 当你 想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 

 那么 运行这个命令就可以将你所做的备份到服务器：

```bash
git push origin master
```

### 打标签

##### 附注标签

> git tag -a v1.4 -m "my version 1.4"

-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，

Git 会启动编辑器要求你输入信息。 通过使用 git show 命令可以看到标签信息和与之对应的提交信息

#### 轻量标签

```bash
git tag v1.4-lw
```

### GIT分支 (平行宇宙)

> 使用分支      你可以把你的工作从开发主线上分离开来

Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 

##### 分支创建

```bash
git branch 创建分支名字
```

<img src="D:/OneDrive/OneDrive%2520-%2520v1nqb/%25E6%25A1%258C%25E9%259D%25A2/AppData/Roaming/Typora/typora-user-images/image-20220116203011888.png" alt="image-20220116203011888" style="zoom:50%;" />

那么，Git 又是怎么知道当前在哪一个分支上呢？

 也很简单，它有一个名为 HEAD 的特殊指针。 

在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。

##### 分支切换

```bash
git checkout testing
```

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116203351056.png" alt="image-20220116203351056" style="zoom:33%;" />

那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：

```bash
vim test.rb
git commit -a -m 'made a change'
```

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116203445775.png" alt="image-20220116203445775" style="zoom:50%;" />

如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所 指的对象。 这就有意思了，现在我们切换回 master 分支看看

```bash
git checkout master
```

一是使 HEAD 指回 master 分支

二是将工作目录恢复成 master 分支所指向的快照内容。 

也就是说你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。

##### 创建分支并且切换到此分支

```bash
git branch -b <分支名>
```

##### 删除分支

```bash
git branch -d <branch-name>
```

##### 分支的合并

```bash
git merge <分支名>
```

## GIT进阶

### GUI 图形界面 IDE VSCODE

### 冲突解决

commit 修改并且commit 了 同一个文件  

### rebase 变基



# 《穿越计算机的迷雾》

​	注：根本没咋看的懂，等第二次在看懂吧，第一次先稍微了解一下。

## 1.不知该如何起名的区域

​	比特是计算机专术里使用的比较多的术语之一。

​	二进制小数有多种表示方法，比如把二进制数划分为整数部分和小数部分。

## 2.电与磁

​	奥斯特发现了电生磁：当一根电线有电流通过时就会在它的周围产生微弱的磁场，叫做电流的磁效应。

​	莫尔斯电码通过传输微弱的电流，再远处的终点处打出点或者横线，横线是电流持续存在的结果。

​	第一个预言电磁波存在的人是麦克斯韦，第一个用实验证明麦克斯韦预言的人是赫兹

​	自感能够产生瞬时高压，它可以发生在线圈断电的一瞬间，也可以发生在线圈通电的一瞬间。可以这样认为：当线圈通电或断电时，他的磁场会急剧发生变化从而产生对自身的感应电压。

​	电磁波又叫无线电波。

​	交流电的波形是周期性重复的。

## 3.思维

​	思维包括形象思维和抽象思维。

### 1)形象思维

​	形象思维包括借助于具体的形象，或者外部事物在大脑中的印象而产生的联想和想象。形象思维接近于人类的本能，形象思维不拘一格，没有定式，取决于你是否见多识广，也和你个人的某些特点有关，用于艺术创作或者是发明创造。

​	形象思维的想象与联想不同，抽象思维总是要从已知的事实出发，计算出一个结果，得出一个新结论；或者用一组被公认为真实的材料，证明某种观点或说法。

​	形式思维不存在正确与否的问题，因为形象思维是发散的、自由的、无拘无束的、没有定式的，不需要猜测，不需要规则，只要你有足够的想象力。

### 2)抽象思维

​	抽象思维不借助于头脑中的形象。抽象思维无处不在，每时每刻都存在于人类的大脑当中。抽象思维是人类的最主要的思维方式，也差不多是人类所特有的。

​	对于抽象思维来说，概念仅仅是最基本的元素，是出发点。要进行真正的思维和推理，概念之间需要用连接词串联在一起，在大脑中形成一个意思，一个论断，或者断定，这叫做命题。

​	多数命题是位于大脑中的经验和知识，这些经验和知识是你从小通过玩耍、观察、推理和学习各门功课形成的。

​	一个完整的抽象思维过程是从概念到命题，再到推理。

​	与形式思维不同，抽象思维通常被认为是在追求真理，因此会出问题。由于抽象思维包括概念、命题和推理，一旦其中的某一个出错，就大错特错了。

## 4.逻辑性

### 1)介绍

​	逻辑学是哲学的一个分支，而哲学以深奥晦涩而著称，因此逻辑学也不是十分好懂的。逻辑学是一门实用性很强的科学，属于七大基础学科之一。

​	逻辑学的产生和发展说明了一个基本事实，即人类在抽闲思维方面不是完美的，或者说是有缺陷的。逻辑学的任务就是总结抽象思维的规律和特点，让人们在掌握他之后可以明辨是非，去伪存真，也会使得人在说话或者思考问题的时候，从一开始就会有着很强的思维能力和很高的思维品质。

### 2)内容

​	逻辑学首先产生了概念和命题，并在此基础上形成了一些公认的准则。

​	在逻辑学中，概念和其运用是一个复杂的话题。逻辑学要求，在一个单独的抽象思维过程中，概念和命题必须保持一致，这叫做同一律。

​	正常情况之下，人们总会保持着同一律，这是人在出生之后一直从周围学习并不断强化的结果。但同一律不是唯一的逻辑准则，还有其他的，比如矛盾律（从逻辑学上来说，在一个独立的抽象思维过程中，会相对立的命题之间不能同时为真，也不能同时为假）。

### 3)古典逻辑

​	古典逻辑是相对而言的，是有亚里士多德创造的。主要研究的是逻辑准则和逻辑规则，也会研究推理形式。归纳推理是基于归纳以往的情况得出的结论，但其结果往往是靠不出的。类比推理是进行对照，从而将结果认为相同。

### 4)演绎逻辑

​	演绎逻辑或者说是形式逻辑，侧重于从形式上进行的推理和论证。

### 5)联言推理

​	对一些语句进行对应的联系，看起来是十分笨拙的，但人却能够十分自然的做出来。

​	在两个或两个以上的命题之间进行。

​	支命题间的连接词通常是“并且”。

### 6)选言推理

​	也是在两个或两个以上的命题之间进行。

​	支命题间的连接词通常是“或者”。

​	选言推理研究的对象是那些支命题中至少有一个为真的选言推理。

​	逻辑学对选言推理的第一个重要结论是如果有一个支命题为假，那么其他支命题至少有一个为真。

​	相容的选言推理：所有支命题之间不是排斥和对抗的关系，他们有可能同时为真。而不相容的选言推理则是在这些支命题中只有一个为真。

### 7)逻辑代数

​	是布尔将逻辑进行了数学化，并创建的一门学科，逻辑代数。好处是同一个证明过程可以用来解决不同的、但本质上属于同一种类型的逻辑问题。

### 8)数字电路和逻辑电路

#### 	i)非门

​	当A闭合时，F会打开；相反，A打开的时候，F会关闭。

![image-20211227160039112](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227160039112.png)

​	在一个完整的电路当中，各个组成部分会共用电源。

​	接地符号：

​		更常用的是第一项。

![image-20211227160348310](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227160348310.png)

​		非门符号：

![image-20211227161253549](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227161253549.png)

#### 		ii)与门

​			![image-20211227162212649](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227162212649.png)

#### 		iii)或门

![image-20211227162138442](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227162138442.png)

#### 		iv)异或电路

​		与逻辑电路当中的异或门相似。

![image-20211227162733112](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227162733112.png)

​		异或门的符号与逻辑表达式：

![image-20211227164214656](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20211227164214656.png)

​		各图当中的A，B点不是金属探头或者裸露的电线之类，而是双芯电缆。电压只存在于电源的正负两极之间。

#### 		v)电子三极管

​			可以通过微调电源做出较大的改变。

![image-20220108172715735](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108172715735.png)

#### 		vi)触发器

​		具有记忆能力。

​	![image-20220108172130116](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108172130116.png)

![image-20220108172248042](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108172248042.png)

![image-20220108172302351](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108172302351.png)

​		利用一个比特来保存一个比特：

![image-20220108173036876](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108173036876.png)

​		但上面这种情况下，只能保存0，无法保存1。

​		所以进行了改进：变为了D触发器，只有CP有输入时才有可能对触发器进行修改。

![image-20220108173307096](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108173307096.png)

​		当想保存的时候，是CP有输入，反之则无输入。

#### 		vii)移位寄存器

​			可以用来保存多个比特，并将这些比特顺序左移或者右移。

​			有一种特例叫做振荡移位寄存器，就像走马灯一样，可以保存0/1,并且持续不断的连续输出。

​			并行：几个比特同时进入

​			串行：依次进入

#### 	viii)利用乒乓触发器的组合计数

​			最大可计到2^n-1这个数。

![image-20220108181314517](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108181314517.png)

## 5.数字计算机发展

### 	1)硅

​	制备过程中的掺杂：通常需要在通有杂质气体的高温炉里进行,当硅和锗处于熔融状态的时候,杂质气体便能渗透到里面,并产生一些奇特的物理过程.在掺杂的过程中,像氧气这类东西是不受欢迎的.

​	在纯净本征的半导体上一边掺上硼，另一边掺上磷，然后分别引岀两根导线，半导体的导电性就会大幅度提高。

​	如果在半导体中掺入砷、镓等原子，制作出来的晶体二极管就会发光，称为发光二极管（LED）。要是进行一些特殊处理，还可以控制光的颜色。

### 	2)加法器

​		利用寄存器，使得可以完成多个数据的相加。

​		临时寄存器TR用来临时保存加法器的计算结果。

![image-20220108182137108](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220108182137108.png)

​		规律简化设置：

​		![image-20220115225425694](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220115225425694.png)

​	通过一个开关来调整四个开关的情况，从而简化操作，并且将要循环开启的开关用循环移位寄存器来代替，使步骤更加简化。

​	可以唯一的保存一个比特，并且输入输出：

![image-20220116131235656](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116131235656.png)

​	可以将上面的装置叠加起来，组成保存二进制数，甚至是多个二进制数：

![image-20220116131619586](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116131619586.png)

​	当存在多个的时候，势必不可能一个一个的去调试开关，就是用了另一种装置：

![image-20220116132348452](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116132348452.png)

​	地址是指向存储器内部的一小块区域，这是真正存储着数据的地方，这个地方叫做数据单元。

​	构造地址译编器需要详细地址定义一张符合符合其状态的真值表，并依据该表写出各项输出的逻辑表达式。

### 	3)存储

#### 	i.磁芯

​		磁芯来保存数据是利用了电流能产生磁场，有些东西在磁化之后会产生剩磁，而且，不同的电流方向将使磁芯按不同的方向磁化。

​		如果把一种剩磁状态看成“0”而另一种状态看成“1”，那么磁芯可以用来保存1个二进制比特。

​		在磁芯中穿一根电线，叫做驱动线，用来往磁芯中写入一个比特，称作驱动线，因为读出比特的时候也要用到它。要达到写入一个比特的目的，需要控制电流的方向。要把这个比特读出来 需要在它里面穿另一根电线，叫做读出线。

![image-20220116155326588](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155326588.png)

![image-20220116155340745](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155340745.png)

​		磁芯的读出是破坏性的。如果读出来的是“1”，那么读取之后磁芯的状态将会是“0”，这需要重新将读出来的“1”写回磁芯中。

​		好处：断电之后，也能够维持写入的数据。

#### 		ii.地址

​		![image-20220116155549868](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155549868.png)

![image-20220116155618134](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155618134.png)

### 	4)半自动操作的加法器

![image-20220116155757981](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155757981.png)

以操作码开始的指令：

![image-20220116155911491](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116155911491.png)

​	将到现在的所有操作叠加到一起，可以设计出一个只需要按开关的半自动加法器，可以在按下开关之后自动将数字相加，直道所有指令全部完成。

### 	5)全自动的加法器

​		全自动加法器是重新设计指令译码电路EC使其可以译出I(停机).

![image-20220116160254797](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116160254797.png)

## 6.现代计算机

​		图灵机并未真正的研发出来，现代的计算机大多都是冯·诺依曼结构体。

​		指令有很多种，有装载指令。

​		用装载指令时，如果一个数字直接从指令中获取，是指令的组成部分，叫做立即数。

​		一个字节=8位

​		将加减乘除这四种运算功能的电路结合在一起，称为运算器。

​		所有的寄存器，以及任何一个存储单元，都可以装载一个包含在指令中的立即数。

​		任意两个寄存器之间，或者寄存器和存储单元之间，都可以互相装载数据。

​		所有的寄存器，以及任何一个存储单元，都可以和包含在指令中的立即数进行加、减、乘、除运算，结果依然返回该寄存器或者存储单元。

​		寄存器之间，或者寄存器和存储单元之间，都可以互相进行各种数学运算。

​		计算机刚开始以晶体管为材料制作的后来被集成电路取代。

​		放电的速度取决于两个极板之间的电阻，利用电容器充放电的特点来保存1个二进制的比特。充了电的电容器相当于 “1”，没有充电的相当于“0"。

​		电容器在充电之后，即使放在那里不用，也会通过隔在两极间的空气或者其他介质慢慢放电，这称为泄漏。

​		只读存储器最大的优势在于可以一直维持它所保存的内容。

​		微处理器更多地被称为中央处理器。

​		论访问速度，由触发器组成的内存（SRAM）是最快的，一般为几纳秒。与之相比，动态存储器（DRAM）就差些，访问速度可能是几十纳秒，很大一部分原因在于它需要频繁地刷新，在此期间无法接待处理器的造访。

​		数据加工：

![image-20220116180120664](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116180120664.png)

​		流水线过程：

![image-20220116180132663](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220116180132663.png)

​		为处理器增加分支预测功能。通过为处理器增加额外的电路，来预测将要发生的跳转，分支预测不会百分之百成功，但可以一定程度上解决跳转指令所造成的影响。

​		不停地观察模拟信号的幅度，并得到一个个的二进制数，称为“采样”。

​		I/O接口有多种功能，其中最重要的是模一数和数一模转换。

​		每个I/O接口也都有一些寄存器，称为端口，用来保存各种数据，比如釆样数据和代表设备状态的数据，以及控制设备如何工作的数据，中央处理器提供专门的I/O端口读写指令来与外部设备相接。

​		显存通常位于负责显示图像的I/O接口中，一般来说是一块独立的接口卡，称为显卡。

​		并不是所有数据都可以被压缩，尤其是不存在重复内容的时候，压缩之后反而会增加数据量。由于图像由像素组成的，行程编码的方法对于压缩图像特别有效，而像素则是一些表示颜色的二进制数据，而且图像中总是包含大量具有相同颜色的像素。

​		光纤就是光导纤维，它是玻璃或塑料制成的纤维，它有优良的全反射性能来传导光线。

​		

# 《计算机系统结构基础》

## 1.引言

​	通用计算机系统结构图：

![image-20220117090956856](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117090956856.png)

​	应用程序编程接口-API(介于应用程序和操作系统之间，在编写程序源代码时使用)，指令系统-ISA(介于操作系统和硬件系统，是软件兼容的关键)，工艺模型（芯片生产厂家提供芯片设计者的界面），应用程序二进制接口-ABI（应用程序访问计算机硬件及操作系统服务的接口）。

​	计算机的记忆(运算器和控制器，即CPU)和存储(存储器存储着指令和数据)是分开的。

​	冯·诺依曼计算机基本思想：数据和程序都在存储器中，CPU从内存中取指令和数据进行运算并把结果也放到内存中。

​	冯·诺依曼结构最核心的数学思想是存储程序和指令驱动执行。

​	性能最本质的定义是“完成一个任务所需要的时间”。

​	计算机的重要指标有性能、价格、功耗

​	优化芯片功耗的方法有动态功耗优化（升级工艺是有效方法）和静态功耗优化（选择低功耗工艺或者避免不必要的逻辑翻转）。















# 《数字设计与计算机体系结构》

## 一.二进制

### 	1)控制复杂性

​		管理复杂性的关键技术在于抽象：隐蔽不重要的细节。

​		约束是对设计选择的一种内在限制。通过这种限制可以更有效地在更高的抽象层次上工作。例如：使用可互换部件。

​		数字电路使用离散电压，模拟电路使用连续电压。

​		数字电路是模拟电路的子集，而且在某种意义上能力弱于范围更广的模拟电路。

​		三条准则：层次化、模块化、规整化

​			层次化：将系统化划分为若干模块，然后更进一步划分每个模块直到直到这些模块可以很容易理解。

​			模块化所有模块都有定义好的功能和接口，以便于他们之间可以很容易的相互连接而不会产生	副作用。

​			规整化：在模块间寻求一致，通用模块可以使用多次，减少设计不同模块的数量。

### 	2)数字抽象

​		数字抽象的优势在于设计者可以只关心0和1，而忽略布尔变量的物理表示到底是什么，是计算机编程人员不需要了解计算机硬件的细节就可以使用。

​		电子计算机普遍使用正电压为‘1’，0电压为’0’。

### 	3)进制

​		二进制数中每一列的权都是2的倍数，从后往前，第n位是2的n-1次。

​		16进制中的数字是由0~9和 A~F组成。

​		二进制-->十六进制：将二进制的四位换算成十六进制的一位。反之，一换四。

​		十进制-->二进制/十六进制：从小于十进制数的最大幂次数开始，用除法，余数是下一次除法的除数，直到结束。

​		8位一组为字节，4为一组为半字节

​		计算机中存储习惯上以字节为单位。

​		微处理器处理的一块数据称为字，字的大小处于未处理器的结构。

​		在一组位当中，权为1的那位称为最低有效位（最低有效字节），另一端的位称为最高有效位（最高有效字节）。

​		二进制加法如果溢出，且不允许多出位数，会将最高位抛弃，留下一个不正确的结果。

​		带符号的二进制数：

​			带符号的原码：把N-1位为绝对值，第N为为正负号表示处（0为正，1为负）

​			二进制的补码：求二进制补码过程中二进制补码的符号位不变。首先对数据的每一位取反，然后在最低位+1。二进制补码的表示范围是[-2^N , 2^N-1]。补码加法中判定的溢出条件是如果相加的两个数符号相同而且结果的符号于被加数的符号相反则表示发生溢出。

​		数制的比较：

![image-20220117104828342](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117104828342.png)

### 	4)逻辑门

​		两输入逻辑门常见的有：非门(NOT)、缓冲区(BUF)、与门(AND)、或门(OR)、异或门(XOR)、与非门(NAND)、或非门(NOR)。

​			带着小气泡的表示取反。

![image-20220117105157177](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117105157177.png)

![image-20220117105414614](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117105414614.png)

​		多输入逻辑门同样符合逻辑门的基本规则，只是输入的数据增多。

### 	5)数字抽象

​		逻辑电平：

![image-20220117110445452](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117110445452.png)

​		噪声容量









### 	6)功耗

​		功耗是单位时间内所消耗的能量。数字系统包括动态功耗（0和1之间变化时电容器充电所耗费的能量）和静态功耗（信号不变，系统空闲时的功耗）。

​			电容电压切换的频率为f（每秒变化f次），1秒内充电f/2次，放点f/2次。将电容器充到Vdd所需的能量为C*(Vdd…^2)。

![image-20220117150905988](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117150905988.png)

​			晶体管处于截止状态也会泄漏少量电流，这个静态电流称为电源与地之间的漏电流或静态电源电流。

![image-20220117151323813](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220117151323813.png)

## 二.组合逻辑设计

### 	1)定义

​		元件本身是一个带有输入、输出、功能规范和时序规范的电路。

​		节点是一段导线，是通过电压来传递离散变量，可以分为输入节点、输出节点和内部节点。

​		数字电路可以分为组合电路(输出仅取决于输入的值)和时序电路(输出取决于当前输入值和之前输入值)。

​		组合电路需满足的条件：

​				每一个电路元件都是电路本身

​				每一个电路的节点或者是一个电路的输入，或者是连接到外部电路的一个输出端

​				电路不包含回路：经过电路的每条路径最多只能经过每个电路节点一次

### 	2)布尔表达式

#### 		i.定义等术语

​			一个变量A的非是它的反，记作A’(应该是A上面多一横杠)。变量或者是它的反都称为是项，其中A是真值形式，而A‘是取反形式。

​			一项或多项的AND称为是乘积项(活着蕴含项)。最小项是一个包含全部输入变量的乘积项。

​			一项或多项的或称为求和项。一个最大项包括了全部输入项的和。

​			优先级顺序：非(NOT)>与(AND)>或(OR)

#### 	ii.与或式

​		可以将与或式的形式改变

![image-20220121230951755](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121230951755.png)

![image-20220121230913951](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121230913951.png)

#### 		iii.或与式

![image-20220121232035778](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121232035778.png)

![image-20220121232052628](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121232052628.png)

#### 		iv.布尔代数

​			公理：

![image-20220121232246461](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121232246461.png)

​			单变量定理：

![image-20220121232323572](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220121232323572.png)

​	多变量定理

![image-20220122091629905](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220122091629905.png)



​	一个与非门等于一个带逆变器输入的或门，一个或非门等于一个带反向输入的与门

​	逆变器也可称为是气泡。

​	制作电路图时须遵守的准则：

![image-15622122710780](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-15622122710780.png)

​		另外三条线的准则：

![image-20220122122737499](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220122122737499.png)

### 	3)X和Z

​		1.X表示电路节点有未知或非法值，一般情况是同时连接一个高电平和低电平，导致冲突，称为“竞争”。

​			X值有时也被电路仿真器用来表示一个没有初始化的值。当X出现在真值表当中的时候通常表示一个不重要的值。

​		2.Z表示结点既没有被高电平驱动也没有没被低电平驱动，这个节点叫做浮空、高阻态。

​			浮空节点可能是0~1之间的任意一个值，取决于系统的先前状态。

​			这并不意味着电路出错，当被驱动到电平的时候，是可以进行电路的操作的。

​			三态缓冲器：

![image-20220124183805587](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220124183805587.png)

​				使用多个三态缓冲器可以避免读取信息的竞争

![image-20220124183859629](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220124183859629.png)

### 	4)卡诺图

​		一种用图形化的方式将布尔代数表达式进行简化的方法，对于四个变量以下的有奇效。

​		两个放到一起的或以格雷码(00/01/11/10，相邻项中只有一个变量不同)的方式排列，

![image-20220124185320042](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220124185320042.png)

​		通过将值为1的部分圈到一个圆内，就可以将园内的部分相加然后再化简。卡诺图是环形的，右边与左边的是相接的，可以从右边圈到左边。

​		画出的每个圈都是一个蕴含项，最大的是主蕴含项。

​		某些对输出没有影响的值可以被认为是无关项，一般用X表示，有时甚至可以将X和1圈到一起来帮助化简逻辑。

​		规则：

​			i.用最少的原来圈住所有的1；

​			ii.每个圆的方格都必须包含1；

​			iii.每个圆必须是矩形，其每边长必须是2的整数次幂（如：1/2/4）；

​			iv.每个圆必须尽可能大；

​			v.圆必须环绕卡诺图的边界；

​			vi.如果可以使用数量更少的圆，则卡诺图中一个为1的方格可以被多次圈住；

​	再将每个圆的布尔代数式加到一起，化简，即可得出最后的表达式。

### 	5)组合逻辑模块

#### 		1.复用器

​			复用器是一种最常用的组合逻辑电路，可以根据信号的值从多个的输入中选择一个作为输出，简称为mux。

​			原理图和真值表如下（S为控制信号，会控制选择哪个值）：

![image-20220124210652611](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220124210652611.png)

​			复用器可以通过查找表的方式来实现逻辑功能。

#### 	2.译码器

​		译码器由N个输入，2^N个输出。

​		在给定时间内值有一个高电平的称为“独热”。

​		28译码器：

![image-20220125120407966](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220125120407966.png)			![image-20220125120353657](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220125120353657.png)

### 	6)时序

​		如何使得电路运行的快是电路当中最具挑战的的一个问题。

​		时序图：可以显示缓冲器的一个输入改变和输出改变所产生的延迟的图像，描绘了当输入改变时缓冲器电压的瞬间响应。从高电平到低电平为下降沿，反之为上升沿。

​		时序特征包括：传播延迟(t(pd)当输入改变直到一个或多个输入达到它们的最终值所经历的最长时间)和最小延迟(t(ed)当一个输入发生改变直到任何一个输出开始改变的最短时间)。

​		电路产生延迟的基本原因：电路中电容器充电所需的时间和光速

​		t(ps)和t(ed)值不同的原因：

​			i.不同的上升和下降延迟。

​			ii.多个输入与输出之间的延迟可能不同。

​			iii.当电路较热时速度会变慢，较冷时会较快。

### 	7)毛刺

​		一个输入信号的改变可能会导致多个输出信号的改变，称之为毛刺或者是冒险。

​		简而言之就是一条输入发生改变，然后使得两个路径上的值改变，一条快一条慢，一条改变使得输出改变，另一条发生改变又使得输出再次改变。

## 三.时序逻辑设计

​		时序逻辑取决于当前输入值和先前的输入值。

​		一个数字时序逻辑电路的状况由一组称为状态变量的位构成，这些状态包含用于解释电路未来行为所需要的有关过去的所有信息。

### 	1)锁存器和触发器

​		存储器件的基本模块是一个双稳定元件，该元件有两个稳定状态

​		示例：

​		这类稳态是循环的，将这个值的输出作为另一个的输入，而且保持不变，并不冲突：分别为Q=0和Q=1这两种情况

​			![image-20220204123134594](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204123134594.png)

​		电路还存在第三种稳态，介于0~1之间的，称为亚稳态，在后面会提到。

​		这种电路启动之后就会是恒定的，但是在开始的时候会有不确定性。

#### 			1.SR锁存器

​			SR锁存器是最简单时序电路，与上面提到的交叉耦合的电路类似，但是它可以通过输入端S、R来控制状态，原理图如下：

​				![image-20220204132259355](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204132259355.png)

​			真值表及其符号：

​				![image-20220204152045803](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204152045803.png)

​			当SR均为0的时候，Q和Q’的值保持不变。

​			缺点：会混淆时间与内容。需要考虑何时改变，以及需确定内容是什么。

#### 		2.D锁存器

​			D锁存器将时间与内容分开，一个用来控制状态，另一个用来控制状态发生改变的时间。

​			当CLK为0时，(D锁存器是非透明的)不论D为多少，Q与Q’的值均不变；在CLK为1的时候，(D锁存器是透明的)D的状态与Q相同，D’与Q’状态相同。

​			D锁存器又叫做透明锁存器或者是电平敏感锁存器。

​			原理图、符号以及真值表如下：

​				![image-20220204153155954](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204153155954.png)

#### 		3.D触发器

​			由反向时钟控制的两个背靠背的D锁存器构成，有主从之分。

​			原理图、符号如下：

​				![image-20220204153853744](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204153853744.png)

​			D触发器在时钟上沿将D复制到Q，其他时间D触发器保持原本的状态。

#### 		4.寄存器

​			一个N位寄存器由共享一个公共CLK输入的一排N个触发器组成，所有位会同时被更新。

​			通常作为时序电路的关键组件。

​			四位寄存器的原理图和符号：

​				![image-20220204154449904](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204154449904.png)

#### 		5.带使能端的触发器

​			相比D触发器，增加了一个ENABLE的输入，可以用于确定在时钟沿是否载入了数据。

​			原理图以及符号：

​				![image-20220204154913866](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204154913866.png)

​			时钟门控可能会导致时钟延迟并导致时序错误。

​			在CLK为1的时候，EN不能改变，以免处发器出现一个时间毛刺(在不正确的时间进行切换)。

#### 		6.带复位功能的触发器

​			相较于D触发器，增加了一个RESET的输入。当RESSET为0时使得Q的值复位为0，而

​			同步复位触发器原理图以及符号：

​				![image-20220204190245389](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204190245389.png)

​			异位复位触发器需要调整触发器的内部结构。

​		7.晶体管级锁存器和触发器的设计 

​				利用一个单独的传输们门设计紧凑D锁存器，其原理图如下：

​				![image-20220204190846309](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204190846309.png)

​				这种锁存器的缺点：

​					i.输出节点浮空：当锁存器不透明的时候，没有任何一个门来保存Q值。所以Q称为浮空节点或者是动态结点。时间变长之后，噪声和电荷泄漏会干扰Q的值。

​					ii.没有缓冲器(看不懂)：![image-20220204191332584](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220204191332584.png)

#### 			8.小结

​			D锁存器是电平敏感的，而D触发器是边沿触发的。

​			寄存器由一个公共CLK信号的一排多个D触发器构成。

### 2)同步逻辑设计

#### 	1.有问题电路

​		第一种是非稳态电路。多个电路元件并未构成一个有效的循环

​		环形振荡器：刚开始的数值与过程中的数值一直在改变，是例如：零输入和一个(周期性改变)输出的时序电路。

​			![image-20220205093236056](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220205093236056.png)

​		环形振荡器的周期取决于每个反向器的传播延迟。

#### 		2.同步时序电路

​			通过电路的输入、输出端、功能规范和时序规范可以定义一个电路。

​			一个时序电路有一组的有限的离散电路。

​			同步时序电路有一个时钟输入，它的上升沿表示时序电路状态转变发生的时间。通常以当前状态和下一个状态来区分目前系统的状态和下一个时钟沿系统将进入的状态。

​			时序规范包括上界时间t~peq~和下界时间t~ccq~，它是从时钟上升沿直到输出改变

​			组成同步时序电路所需要满足的条件：

​				i.每个电路元件必须是寄存器或者是组合电路

​				ii.至少有一个电路元件是寄存器

​				iii.所有寄存器都接受同一个时钟信号

​				iv.每个环路至少包含一个寄存器

​			非同步时序电路被称为异步电路，通常来说异步电路更加通用。

#### 3)有限状态机

​		具有k位寄存器的电路可以处于2^k^种状态中的某一状态。

​		一个有限状态机有M个输入，N个输出和k位状态，还可以接受一个时钟信号，和一个可选择的复位信号。

​		有限机的状态包含两个组合逻辑块，“下一个状态逻辑”和“输出逻辑“，以及一个存储这个状态的寄存器。

​		有限机通常分为两类

​			![image-20220207160902856](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220207160902856.png)

​			Moore型有限状态机，输出仅仅取决于机器的当前状态(系统的状态)。

​			Mealy有限状态机，输出取决于当前状态和当前输入。

##### 1.状态编码

​		状态编码：一个重要决策是选择二进制编码还是独热编码

​		二进制编码：一个二进制数代表一种状态

​		独热编码：状态里的每一位表示一种状态，任何时候每一位只有“热的”和“TRUE”的区别。状态的每一位存储在一个触发器当中，所以独热比那吗需要更多的触发器，下一个状态和输出逻辑比较简单，所需的门电路更少。

​		独冷编码：用K位表示K个状态，其中的一位恰好为FALSE。

​		最佳编码方式取决于具体的有限状态机。

##### 2.状态机的分解

​		将复杂的有限机分解成多个相互作用的更简单的状态机，使得其中的一些状态机的输出是另一些状态机的输入，这种应用层次化和模块化的方法称为状态机的分解。

##### 3.由电路图导出状态机

​		i.检查电路，标明输入、输出和状态位

​		ii.写出下一个状态和输出等式

​		iii.创建下一个状态和输出表

​		iv.删除不可达来简化下一个状态表

​		v.给每个有效状态位组合指定状态名称

​		vi.用状态名称重写下一个状态和输出表

​		vii.画出状态转化图

​		viii.使用文字阐述有限状态机的功能

##### 4.设计有限状态机步骤

​		确定输入和输出

​		画状态转化图

​		对于Moore型状态机

​				写出状态转化表

​				写输出表

​		对于Mrely型状态机

​				写出组合状态转化表和输出表

​		选择状态编码----会影响硬件设计

​		未下一个状态和输出逻辑写出布尔表达式

​		画出电路草图

#### 4)时序逻辑的时序

​	时钟沿对D采样是触发器在时钟的上升沿将输入D复制到输出Q。

​	时序元件在时钟沿也有孔径时间



















# shell脚本

## 1.



















# C中的正则表达式

每种语言都对正则表达式有着不同程度的支持，在C语言中，有输入功能的这三个函数对正则表达式的支持并不强大，但是我们还是有必要了解一下。

## 原型：

```c
#include <stdio.h>
int scanf(const char *format, ...);
int fscanf(FILE *stream,const char *format, ...);
int sscanf(const char *str, const char *format, ...);
```

均可以接受变参，sscanf与scanf类似，可以将标准输入（stdin）作为输入源。最关键的部分，就是format这个参数了。它可以是一个或者多个 {%[*] [width] [{h | l | I64 | L}]type | ' ' | '\t' | '\n' | 非%符号}。

## 参数解释：

　　1、 * 亦可用于格式中, (即 % * d 和 % * s) 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)

　　2、{a|b|c}表示a,b,c中选一，[d],表示可以有d也可以没有d。

　　3、width表示读取宽度。

　　4、{h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。

　　5、type : 就是%s,%d之类。

　　6、特别的：%*[width] [{h | l | I64 | L}]type 表示满足该条件的被过滤掉，不会向目标参数中写入值

支持的集合操作：%[a-z] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)%[aB'] 匹配a、B、'中一员，贪婪性%[ ^a] 匹配非a的任意字符，贪婪性

## 返回值

这三个函数返回成功匹配和分配的输入项。意思就是你在format参数列表中的格式，返回值可以比你提供的匹配项目数少（有些将会匹配失败）。提前匹配失败则返回0。如果达到文件末尾，则返回EOF，当发生错误的时候也将返回EOF。你可以通过输出errno来查看错误代码。

如果使用fscanf来判断文件是否结束，将会存在安全隐患，如果每次读取的时候都是匹配失败，那么返回值永远都不会是EOF。scanf族的函数都是要先将数据读入缓冲区，然后在冲缓冲里读取。

注意：scanf族函数会忽略一行开始的空白

## sscanf/scanf正则用法

### %[ ] 的用法：

>  %[ ] 表示要读入一个字符集合 , 如果 [ 后面第一个字符是 ”^” ，则表示反意思。
>
> [ ] 内的字符串可以是 1 或更多字符组成。空字符集（ %[] ）是违反规定的，可
>
> 导致不可预知的结果。 %[^] 也是违反规定的。

### %[a-z] 

​	读取在 a-z 之间的字符串，如果不在此之前则停止，如

```c
char s[]="hello, my friend” ;
// 注意 : , 逗号在不 a-z 之间
sscanf( s, "%[a-z]", string ) ; 
// string=hello
```

### %[ ^a-z] 

​	读取不在 a-z 之间的字符串，如果碰到 a-z 之间的字符则停止，如

```c
char s[]="HELLOkitty" ;
// 注意 : , 逗号在不 a-z 之间
sscanf( s, "%[^a-z]", string ) ;
// string=HELLO
```

### %\*[ ^=] 

​	前面带 * 号表示不保存变量。跳过符合条件的字符串。

```c
char s[]="notepad=1.0.0.1001" ;
char szfilename [32] = "";
int i = sscanf( s, "%*[^=]", szfilename ) ;// szfilename=NULL, 因为没保存
int i = sscanf( s, "%*[^=]=%s", szfilename ) ; // szfilename=1.0.0.1001
```

### %40c 

​	读取 40 个字符

The run-time
 library does not automatically append a null terminator to the string, nor does reading 40 characters
 automatically terminate the scanf() function. Because the library uses  buffered input, you must press the ENTER key to terminate the string  scan. If you press the ENTER before the scanf() reads 40 characters, it  is displayed normally, and the library continues to prompt for  additional input until it reads 40 characters

### %[ ^=]

​	读取字符串直到碰到 '=' 号， '^' 后面可以带更多字符 , 如：

```c
char s[]="notepad=1.0.0.1001" ;
char szfilename [32] = "" ;
int i = sscanf( s, "%[^=]", szfilename ) ; // szfilename=notepad
```

如果参数格式是： %[ ^=:] ，那么也可以从 notepad:1.0.0.1001 读取 notepad

### 使用例子：

```c
char s[]="notepad=1.0.0.1001";
char szname [32] = "";
char szver [32] = "";
sscanf( s, "%[^=]=%s", szname , szver ) ; // szname=notepad, szver=1.0.0.1001
```

### 总结：

​	 %[ ] 有很大的功能，但是并不是很常用到，主要因为：

1 、许多系统的 scanf 函数都有漏洞 . ( 典型的就是 TC 在输入浮点型时有时会出错 ).
 2 、用法复杂 , 容易出错 .
 3 、编译器作语法分析时会很困难 , 从而影响目标代码的质量和执行效率 .

个人觉得第 3 点最致命，越复杂的功能往往执行效率越低下。而一些简单的字符串分析我们可以自已处理。

## C语言中scanf()，sscanf(),fscanf()的用法和区别

### scanf()，sscanf(),fscanf()区别：

 第一个是从控制台（键盘）输入；
 第二个是从字符串输入；
 第三个是从文件输入；

###  scanf

 scanf()函数根据由format(格式)指定的格式从stdin(标准输入)读取,并保存数据到其它参数.

```c
int main()
{ 
	int a,b,c; 
	printf("输入：a,b,c\n"); 
	scanf("%d,%d,%d",&a,&b,&c); 
	printf("a = %d b = %d c = %d",a,b,c); 
	return 0;
}
```

### sscanf

 函数sscanf()和scanf()类似, 只是输入从buffer(缓冲区)中读取.
 sscanf与scanf类似，都是用于输入的，只是后者以屏幕(stdin)为输入源，前者以固定字符串为输入源

#### 用法：

 %[ ]表示要读入一个字符集合, 如果[ 后面第一个字符是”^”，则表示反意思。[ ]内的字符串可以是1或更多字符组成。空字符集（%[]）是违反规定的，可导致不可预知的结果。%[^]也是违反规定的。

1.常见用法

char buf[512] ;
 sscanf("123456 ", "%s", buf);//此处buf是数组名，它的意思是将123456以%s的形式存入buf中！
 printf("%s\n", buf);
 结果为：123456

2.取指定长度的字符串。如在下例中，取最大长度为4字节的字符串。

sscanf("123456 ", "%4s", buf);

 printf("%s\n", buf);
 结果为：1234

3.取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串。

sscanf("123456 abcdedf", "%[ ^ ] ", buf);
 printf("%s\n", buf);
 结果为：123456

4.取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串。

sscanf("123456abcdedfBCDEF", "%[1-9a-z]", buf);

 printf("%s\n", buf);
 结果为：123456abcdedf
 当输入：　sscanf("123456abcdedfBCDEF","%[1-9A-Z]",buf);
 printf("%s\n",buf);
 结果为：123456

5.取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串。

sscanf("123456abcdedfBCDEF", "%[ ^A - Z ]", buf);
 printf("%s\n", buf);
 结果为：123456abcdedf

6.给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，

先将 "iios/"过滤掉，再将非'@'的一串内容送到buf中
 sscanf("iios/12DDWDFF@122", "%*[ ^ /]/%[ ^@]", buf);
 printf("%s\n", buf);
 结果为：12DDWDFF

7.给定一个字符串“hello, world”，仅保留world。

（注意：“，”之后有一空格，%s遇空格停止，加*则是忽略第一个读到的字符串）
 sscanf(“hello, world”, "%*s%s", buf);
 printf("%s\n", buf);
 结果为：world
 %*s表示第一个匹配到的%s被过滤掉，即“hello,”被过滤了
 如果没有空格则结果为NULL。













# 计算机组成原理(视频部分)

## 第一章

### 	1.计算机的发展历程

#### 		1)硬件

##### 		i.电子管时代

​			**时间**：1946~1957年间

​			**逻辑元件**：电子管

​			第一台电子数字计算机：**ENIAC**

​			适用语言：**机器语言**(是直接与机器对话的语言，由0和1组成)

##### 		ii.晶体管时代

​			**时间**：1958~1964年

​			**逻辑元件**：晶体管

​			**相较于电子管的优势**：体积小，且不易损坏，耗电量大幅降低

​			第一台使用晶体管线路的计算机：**TRADIC**

​			面向过程的程序设计语言：**FORTRAN**

​			**特点**：开始出现了操作系统的雏形

##### 		iii.中小规模集成电路时代

​			**时间**：1964~1971年

​			**逻辑元件**：中小规模集成电路

​			**相较于晶体管时代的不同**：内存的材料发生了改变

​			与此同时，**高级语言**开始了发展，**分时操作系统**的逐步出现，使得计算机的运行更加科学。

##### 		iv.大规模、超大规模集成电路

​			**时间**：1972~现在

​			**新发明**：**微处理器**(使得运算所需的东西仅使用一小部分位置)

​			产生的新概念：**并行**、**流水线**、**高速缓存**、**虚拟存储器**

#### 	2)微处理器

​		微型计算机的发展以微处理器技术为标志。

​		![image-20220301164118443](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301164118443.png)

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301164625927.png" alt="image-20220301164625927" style="zoom:150%;" />

​		**机器机长**：指的是计算机**一次整数运算**所能处理的二进制位数。

​						  机器字长在**一定程度**上决定了微处理器的运算速度。

​		**区分**：**操作系统位数**其所依赖的指令集的位数，影响整个系统访问的存储空间的大小。

​		**摩尔定律**：揭示了信息技术进步的速度。集成电路上可容纳的晶体管的数目，约每隔十八个月便会增加一倍，整体性能也会提升一倍。

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301165331113.png" alt="image-20220301165331113" style="zoom:150%;" />

#### 		3)软件

##### 			i.机器语言/汇编语言

​				面向对象是机器，是能令机器读懂的计算机语言，由0和1组成

​				**缺点**：思维偏向于机器化，在解决一些问题时会十分麻烦

##### 			ii.FROTRAN

​				是针对于设计目标(科学和工程计算)使用的一种计算机语言。

##### 			iii.PASCAL

​				模块化的语言，简单易懂。

##### 			iv.C++

​				面向对象的计算机语言。思考方式更倾向于如何解决问题，可以必变这个问题内部的一些繁杂步骤

##### 			v.Java

​				更适应网络环境的语言。

#### 		4)操作系统的发展

##### 			i.DOS

​			显示：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301170659849.png" alt="image-20220301170659849" style="zoom:150%;" />

##### 			ii.Unix

​				因需批量处理而产生的操作系统

​				显示：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301170807923.png" alt="image-20220301170807923" style="zoom:150%;" />

##### 			iii.Windows

​				图形处理界面

​				因为人们希望计算机的界面更加友好，更适合大多数人的使用

​				显示：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301170916925.png" alt="image-20220301170916925" style="zoom:150%;" />

### 2.计算机的分类

#### 	1)电子计算机

##### 		i.电子模拟计算机

​		用于处理较为连续的电信号，较短时间内可以传输多个量，但会因为远距离传输或者是强干扰而使计算值发生错误，对环境的要求比较高，故更适用于科研。

##### 		ii.电子数字计算机

​		**按照用途分**:可分为专用计算机(专门使用在某些领域)和通用计算机

#### 	2)按照指令和数据流分类

​		i.单指令流&单数据流(SISD)：代表为冯诺依曼体系结构

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301172045513.png" alt="image-20220301172045513" style="zoom:150%;" />

​		ii.单指令流&多数据流(SIMD)：阵列处理器、向量处理器

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301172210338.png" alt="image-20220301172210338" style="zoom:150%;" />

​		iii.多指令流&单数据流(MISD)：实际是不存在的

​		iv.多指令流&多数据流(MIMD)：多处理器，多计算机

#### 		3)发展趋势

​			i.体积更加小巧

​			ii.计算速度、反应速度更快

### 	3.计算机系统的组成

##### 		i.系统结构

​			软件和硬件在**逻辑**上是**等效**的，但**不是等价**的。

​			![image-20220301173405035](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301173405035.png)

​			具体组成：

![image-20220301173708478](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301173708478.png)

##### 		ii.功能部件

​			运算器的结构：

​				使用的是**组合逻辑设计**。

​			![image-20220301173927203](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301173927203.png)

​			**X**代表了**通用寄存器**。

​			**PSW**叫做**程序状态字寄存器**，用于存放一些状态，也会对一些状态进行判断，比如跳转指令等等经常需要查找程序状态字计算器的

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301174052904.png" alt="image-20220301174052904" style="zoom:150%;" />

​			控制器的**结构**：

​				使用的是时序逻辑设计。

​				CU用于管理整个的操作步骤，能够猜测结果并判断下一步的目标。

​				IR叫做**指令寄存器**，用于存放当前执行的指令。

![image-20220301174404767](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301174404767.png)

##### 		iii.工作过程

​			取数指令

​				![image-20220301175436678](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220301175436678.png)

​		CPU区分数据和指令的**依据**是：指令周期的不同阶段。

##### 	iv.IO设备

​		属于外设内容，有输入、输出设备，也有辅助存储设备。

​		输入设备是将人所理解的通过电信号传递给电脑，使电脑能够理解人的行为与需求。

​		输出设备是将电信号转化为人所能理解的内容传送出来。

​		有些设备可以同时为输入和输出设备。

​		辅助存储器一般有光盘、机械硬盘、U盘、固态硬盘等等。

​		设备与主机的交流是通过IO接口进行的。

##### v.软件系统

​		软件系统包括系统软件和应用软件。

​		系统软件管理整个计算机系统，使系统资源得到合理的调度。系统软件包括操作系统(OS)、数据库管理系统(DBMS)(是用来管理计算机底层的资源)，语言处理程序等等。

​		应用软件使用来完成用户的特定任务的，可以使用系统软件提供的资源接口。

##### vi.编程语言

​		早期为使用二进制的的机器语言，后来出现了汇编语言(通过使用助记符来编写内容)，在之后衍生出了高级语言，如C/C++/Java/Python等。

​		高级语言通过编译程序(通常使用的是编译器)来将高级语言转化为汇编语言，再由汇编语言通过汇编程序(常用汇编器)转化为机器语言；也可以直接一步解释程序，不必转化。

##### vii.结构层次

​		操作系统负责管理系统的资源。

​		软件和硬件并没有严格的界限。

​		软件和硬件的关系：互相依存，协同发展。

​		![image-20220302110113782](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302110113782.png)			

##### viii.冯·诺依曼计算机

​		**存储程序**：将指令以代码的形式事先输入到计算机的主存储器当中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其它指令，直至程序执行结束。

​		**结构**：

​				<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302111350183.png" alt="image-20220302111350183"  />

​		**特点**：

​					<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302111321630.png" alt="image-20220302111321630" style="zoom:150%;" />

##### ix.存储器

​		**结构**：

​				<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302111730058.png" alt="image-20220302111730058" style="zoom:150%;" />

​		**地址寄存器**(MDR)：承接外部送入的地址，这个地址可以定位到存储体内的某个存储单元。

​		**存储体**：接收到地址寄存器传入的地址后，将这个地址对应的数据输出到数据寄存器当中。

​		**数据寄存器**(MAR)：暂存数据，当存储体将数据存入后，数据保留在数据寄存器当中，直到存储体制外的部分将数据取走。

​		**时序控制逻辑**：完成整个流程中对各个部分的控制。

​		**结构**：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302112140080.png" alt="image-20220302112140080" style="zoom:150%;" />

​		**存储元**：可以存储一位数据的信息。

​			**结构**：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302112455964.png" alt="image-20220302112455964" style="zoom:150%;" />

​					上边那个是开关，可以连通内外。坐左边的那个是电容器，可以存0/1的信号。

​		**存储单元**：由多个存储元构成的。

​				**结构**：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302113014289.png" alt="image-20220302113014289" style="zoom:150%;" />

​		**存储体**：由多个存储单元构成的。

​		**存储字**：从存储单元中读出的一个“字”。

​		**存储字长**：存储字的长度，一般是8bit。

​		**字节**：1Byte = 8bit，通常将Byte作为存储的基本单位。

​		为了准确的读取到想要读取的那一行数据，需要在读取那一行的时候将其他的行全部设置为0，并节省计算机资源，这样的实现需要译码器。

​		**译码器**：**n**位地址对应 **2**^n^ 个存储单元。

​		**总容量**：总容量=存储单元个数×存储字长=2^n^×8bit=2^n^×1Byte=2^n^B

​		**注意**：AMR和MDR在制作时一般是做到了CPU里面的。

​				<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220302113931121.png" alt="image-20220302113931121" style="zoom:150%;" />

## 第二章

### 1.进位计数法

​	基数：每个数位所用到的不同符号的个数，例如二进制的基数为两个(0&1)。

​	进制比较：

​		位数：相同的一个数，基数大的进制的数比基数小的进制的数所用的位数少。

​		运算：基数大的进制的运算法则比基数小的进制的多。

​		总结：各有优劣。

​	计算机选择二进制的原因：二进制方便对应到物理器件的状态，如高电平和低电平，灯泡的亮灭等等。

### 2.进制转换

#### 		任意进制转换为十进制：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220308103158047.png" alt="image-20220308103158047" style="zoom:150%;" />

#### 		十进制数转换为任意进制：

​			除基取余：用该十进制数除将要转换的基数，然后第几个余数则为该进制下这第几位(从后到前)。

​								对于非整数部分，应该用非整数乘2，然后将整数部分作为该位的进制数，直到乘完结果刚好为1，但一般情况下是没有尽头的，会一直循环。

#### 		2^n^进制间转换：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220308104141892.png" alt="image-20220308104141892" style="zoom:50%;" />

​				核心是二进制。

​				二进制--->四进制、八进制、十六进制：n位一组，每组转换成对应进制的符号。如果转化时位数不足，整数在高位补0，非整数在低位补0。

​				四进制、八进制、十六进制--->二进制：将每一位转化为对应位数的二进制数。

#### 		真值与机器数：

​				真值是带有正负的数，而机器数是只包含0和1的数，是可以放到计算机中使计算机能读懂的数。

### 3.BCD编码

​			快速转换，一一对应的方式。Binary-Coded Decimal

#### 			8421码

​			(BCD编码的一种方式)映射关系：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220309101319175.png" alt="image-20220309101319175" style="zoom:150%;" />

​			当出现非法位的时候将该部分与0110相加，使这个数不在映射表到回归映射表。

#### 			余3码

​			8421码+(0011)~2~ 	<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220309102311306.png" alt="image-20220309102311306" style="zoom:150%;" />

#### 			2421码

​			改变权重

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220309102346012.png" alt="image-20220309102346012" style="zoom:150%;" />

### 4.字符与字符串

#### 		1)字符

##### 			ASCII码

​				ASCII码将数字、符号、字母等128个字符转化为七位的二进制数

​				其中32~128是可印刷字符，数字是48 ~ 57，大写字母是65 ~ 90，小写字母叫97 ~ 122。

​				每个存储单元存放的内容为字节(Byte)的整数倍，即为8的整数倍。

#### 		2)字符串

##### 			i.大端存储模式

​			存储单元内先存储高位字节，后存储低位字节的顺序

​			四个一组，存储时从左到右。

##### 			ii.小端存储模式

​			存储单元内先存储低位字节，后存储高位字节的顺序

​			四个一组，存储时从右到左。

##### 			iii.汉字的编码

​			流程：

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220309104535233.png" alt="image-20220309104535233" style="zoom:50%;" />

#### 3)校验码

##### 	奇偶校验码

​		在某一位将该书中的1补成偶数或者是奇数位，迎来验证文件是否完整。

##### 	海明校验码

###### 		设计思路

​			分组校验，拥有多个校验位，可以在校验位标出错误。

​		需要的检验位数量：

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220309110427376.png" alt="image-20220309110427376" style="zoom:80%;" />

###### 			求解步骤：

​				首先通过信息位的位数来判断海明码的数量。

​				其次海明码分布在 2^n^ 的位置

​				确定海明码的值：将其他位置上的数的下标写出，并转化为二进制数，其中一竖列的上的为1就将所有为1的异或起来，就可以得到对应位数的海明码的值(从右往左数的第n列就是位于 2^n^ 上的海明码的数)。

​				检查正误：将前面计算海明码时的异或在与海明码进行异或，若结果全为0，则表示无误；反之则表示错误。

###### 		注意：

​				有时信息位的下标并非从大到小，而是从小到大，这个时候就要将之前的计算位置全部反过去。

##### 循环冗余校验码(CRC码)							

###### 	求解步骤

​		信息位数(K位)为题中所告，而校验码位(R位)是根据题中所告的生成多项式的最高次幂来确定的。

​		将生成多项式的每一位展开，写成几乘X的多少次，根据前面的系数得出一个二进制数，将信息位左移R位，用0补齐，将得到的二进制数与系数生成的二进制数进行模2除法，产生余数，这个余数就是校验位。

​	模2除法：将二进制数进行除法，具体为先看最高位，如果最高位为1，上面就填1，然后后面的几位(是被除的那个二进制数的长度减1)如果相同就是0，不同则为1，然后从除数当中搬一位到这个数的后面，继续进行，直到最后一位被搬下去；如果最高位为0，就将这部分数与00…0比较。

###### 	检查和纠错：

​			用得到的二进制数与之前那个系数的二进制数进行模2除法，如果得到余数的是000，则证明无误；反之则发生错误。

### 5.定点数的表示

​	定点数的表示形式有：无符号数和有符号数，有符号数又有原码、补码、反码、移码这些种类。

#### 	1)无符号数

​		全部的二进制数均为数值位，没有符号位，相当于数的绝对值。

​		n位无符号数的表示范围是0~2^n^-1。

#### 	2)机器数与真值

​			通过机器数的第一个二进制数来判断正负。(二进制是B，十进制是D，十六进制是H)

#### 	3)定点表示有符号数

​		添加一个小数点，这个小数点是隐含存储

​		定点数与浮点数的区别：定点数是事先约定，而浮点数是按照规则浮动。

##### 		定点小数

​			定点小数的表示方法是在二进制数中的符号位后添加一个隐含的小数点，这个小数点的位置是使得人更加直观地看到数的大小，计算机并不会进行存储。

##### 		定点整数

​			定点整数的表示方法是在二进制的最后添加一个隐含的小数点，在表示数值的二进制数之后。

#### 	4)原码

##### 		事先约定：

​			用X表示真值，用[X]~原~来表示原码，[X]~补~来表示补码，[X]~反~来表示反码，[X]~移~来表示移码。

​			设置字长为8位(符号位+数值位)，最高为作为符号位。

##### 			纯小数原码

​			如果字长为n+1，则原码小数表示的范围为-(1-2^-n^)<=x<=1-2^-n^(关于原点对称)。

​			小数点(隐含)隔开符号位与数值位。

​			如果不足八位，则向数值位后补零。

​			举例：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310104538740.png" alt="image-20220310104538740" style="zoom:80%;" />

##### 			纯整数原码

​			如果字长为n+1，则原码小数表示的范围为-(2^n^-1)<=x<=2^n^-1(关于原点对称)。

​			逗号(隐含)隔开符号位与数值位。

​			如果不足八位，向符号位和数值位中间补0。

​			举例：![image-20220310104937924](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310104937924.png)

##### 		缺点

​			计算时要考虑符号位的大小，要先将原码的计算转变为无符号数的运算。

#### 	5)补码

​		优势：是两个有符号数可以直接进行相加。

​		简化了有符号数的加法计算，将正数不变，然后使负数原码的数值位取反再+1，符号位仍为1，然后使其与另一个数进行相加。

​		注意：取反加一是一个双向的过程，原码->补码、补码->原码、[X]~补~->[-X]~补~、[-X]~补~->[X]~补~。

​		如果要对补码表示的数进行取其相反数，应该连其符号位一同取反。

​		如果字长为n+1，则补码表示的范围为-2^n^<=X<=2^n^-1(相较于原码多表示一个数：-2^n^)

​		纯小数补码图示：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310111843813.png" alt="image-20220310111843813" style="zoom:80%;" />

#### 	6)反码

​		是一个处于原码与补码之间的状态，正数的原码与反码相同，负数原码的话是数值位进行取反操作得到反码，补码是反码+1。

​		表示范围与原码相同。

#### 		7)相互转化

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310112529257.png" alt="image-20220310112529257" style="zoom: 50%;" />

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310113718232.png" alt="image-20220310113718232" style="zoom:50%;" />

#### 	8)移码

​		是在真值的基础上添加一个常数，也叫做偏置值，通常将这个数取为2^n^。

​		移码计算真值的方法：

​			i.首先将这个移码转化为无符号真值数减去偏置值所对应的无符号真值数

​			ii.直接用这个移码减去偏置值对应的二进制数，得到的补码再转化为真值。

​		移码是为了方便比较数的大小的，而补码是为了方便运算的。

### 6.移位运算

​		平时计算时存在移动小数点的情况，而对于计算机而言，它并不会有单独的空间来对小数点进行存储，所以近似看做有一个固定的小数点，可以对数字进行移动，右移n位可以看做是这个r进制数的十进制情况÷r^n^,左移n位可以看做是这个r进制数的十进制情况×r^n^。

​		移位的方法：

​				i.逻辑移位(适用于无符号数)：左移高位丢失，低位添0,；右移低位丢失，高位添0。

​				ii.算术移位(适用于有符号数)：

​						对于原码，符号位不参与移位，左移右移都填0，左移丢1出错，右移丢1失精。

​						<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310115316909.png" alt="image-20220310115316909"  />

​				iii.循环移位(看不懂+1)

​						![image-20220310115422958](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220310115422958.png)



### 7.加减运算

#### 	基本思路

​			转化为x+y的形式，再使[x]~补~+[y]~补~算出结果。

​			也可以将x,y相加之后再取补码。

​			遇到减法的时候，将被减的那个数取补码时连同符号位一同取反，在进行相加

### 8.溢出

​		二进制数的长度有限，能表示的数也有限。

​		一般将二进制数能表示的区域之外称为溢出，大于该范围的是正溢出(有时也叫做上溢)，小于该范围的称为负溢出(有时也称为下溢)。

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312154020905.png" alt="image-20220312154020905" style="zoom:150%;" />

#### 		判断是否溢出的方法

​				方法一：设A的符号位为A~s~，B的符号位为B~s~，运算结果的符号为S~s~，则溢出表达式的逻辑表达式为V=A~s~B~s~S~s~‘+A~s~’B~s~‘S~s~。若V=0.则表示无溢出；若V=1，则表示有溢出。

​				方法二：根据符号位的进位以及最高数位的进位来判断，利用异或，当且仅当符号位的进位与数位最高位的进位相等时表示未溢出，当这两个有一个为1，一个为0的时候表示溢出，这时若符号位的进位为0表示正溢出，反之表示负溢出。

​				方法三：使用双符号位，正数的符号位为00，负数的符号位为01。计算结果中符号位01表示正溢出，10表示负溢出。

### 9.乘法

​			符号采用异或的方法判断正负。

#### 		正常的乘法

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312165315397.png" alt="image-20220312165315397" style="zoom:150%;" />



#### 		原码一位乘法

​			首先在00.0000后放上其中一个数，进行与正常乘法时相加的步骤相似，并且每进行一次都需要将这个数向右移动一位，最后移完得到的数就是这两个数的乘法结果。

#### 		补码一位乘法

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312170556948.png" alt="image-20220312170556948" style="zoom:150%;" />



是根据后两位的情况确定，且取得最终结果的时候，不取最后一次框住的那两个数。

#### 总结

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312171147392.png" alt="image-20220312171147392" style="zoom:150%;" />

### 10.强制类型转换

​		无符号数和有符号数的转换：不改变数据的内容，只改变数据的解释方式。

​		高字节类型转换为低字节类型(长整数变为短整数)，高位截断，保留低位。

​		低字节类型转换位高字节类型(短整数变为长整数)，符号扩展。补码补1，正常的补0.

### 11.除法

#### 		一般类型的除法

​				与正常整数除法类似，比较大小，若被除数比当前的部分大，则这位为0，相反为1。

​				例：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312172654540.png" alt="image-20220312172654540" style="zoom:150%;" />

#### 		原码恢复余数法

​				先算出除数与被除数的机器码，再算出被除数的补码以及被除数的相反数的补码。

​				将被除数与被除数相反数的补码进行相加，然后将这步的结果与被除数的补码进行相减然后左移一位，在重复步骤，直到刚好除尽或者是商已达到所要求的最大位数。

​				共计左移n次，上商n+1次(n为数值位的长度)。

#### 		不恢复余数法

​				先由a左移，然后再加上b。

​					![image-20220312174454201](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312174454201.png)

​				![image-20220312175141818](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312175141818.png)

​				![image-20220312175510555](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312175510555.png)

#### 		补码加减交替法

​				首先判断被除数与除数同号，则被除数减去除数;一号则被除数加上除数。

​				其次，![image-20220312175856145](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312175856145.png)。

​				![image-20220312180150006](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312180150006.png)

​			![image-20220312180225940](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312180225940.png)

### 		12.浮点数

#### 			基本格式

​			浮点数由阶码和位数组成，阶码常用补码或移码表示，尾数常用原码或补码表示。

​			<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312180553549.png" alt="image-20220312180553549" style="zoom:150%;" />

#### 			真值

​				N = r^E^×M

​				r为阶码的底，通常为2，E为阶码的真值，M为位数的真值。

​				类似于十进制里的科学计数法，损失一定的精度，但是保存起来更加的灵活。

​				阶码E反映浮点数的**表示范围**及小数点的**实际位置**；尾数M,的数值部分的位数n反映浮点数的**精度**。

#### 			规格化

​				规定尾数的最高数位必须是一个有效值。

​				一个非规格化数经过操作变为一个规格化的数的操作：

![image-20220312181930224](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312181930224.png)

​				右规示例：

​						![image-20220312182323170](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312182323170.png)

​			规格化浮点数的特点：<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220312182447483.png" alt="image-20220312182447483" style="zoom:80%;" />

​		出现正下溢或者是负下溢的时候，可以当做机器0来处理，不会报错；而出现负上溢或者是正上溢的时候，是出错的。

### 13.IEEE  754标准(浮点数)

#### 		表示

​	![image-20220317103958982](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317103958982.png)

#### 		规定

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317104158588.png" alt="image-20220317104158588" style="zoom:150%;" />

​		表示范围

<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317104229991.png" alt="image-20220317104229991" style="zoom:150%;" />

​		单精度也就是短浮点数，而双精度是长浮点数。

### 14.浮点数的加减

#### 	步骤

​		0.有时需要根据题示来判断是否要转换格式。

​		i.对阶

​			使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1

​				求阶差，然后对阶。

​		ii.尾数加减

​			尾数进行相减，得到一个新的数，可能会溢出(并非真正的溢出)

​		iii.规格化

​			如果在尾数加减的时候出现了溢出，则对数据进行规格化，如果在规格化后看阶码是否保持正常，如果阶码处显示并非为00/11，表示溢出(真正的溢出)。

​		iv.舍入

​			丢弃尾数的时候如果丢弃的是0，则无需舍入。

​				方法<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317111303029.png" alt="image-20220317111303029" style="zoom: 80%;" />

​		v.判溢出

​				

### 15.强制类型转换

​	不同类型的长度![image-20220317111519268](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317111519268.png)

​	当转换时，有char->int->long->double 、float->double范围、精度从小到大，转化过程中没有损失。

​		常见情况下,int和float均为32位，但是int表示整数，范围是 -2^31^ ~ 2^31^-1 ,有效数字32位，而float表示整数及小数，范围是 ± [ 2^-126^ ~ 2^127^ × ( 2 - 2^-23^ ) ]，有效位数为23+1=24位。int是连续的而float是间断的。

​		int->float：可能会损失精度；float->int可能会溢出及损失精度。

### 16.加法器

#### 	1)算术逻辑单元

​		ALU完成一些算术运算(加、减、乘、除)和逻辑运算(与、或、非、异或)以及一些辅助功能(移位、求补)。

​		ALU的逻辑设计<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317112924015.png" alt="image-20220317112924015" style="zoom:80%;" />

#### 		2)设计加法器

​				利用异或和与门来实现半加器，但是当有多位时，就不可避免的会产生进位，会出现三个输入，就需要使用全加器(由两个半加器组成)。

##### 		串行加法器

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317114128819.png" alt="image-20220317114128819" style="zoom:150%;" />

​		只有一个加法器，数据逐位串行送入加法器中进行运算。进位触发器用来寄存进位信号，以便参与下一次运算。

​		缺点：如果操作数有n位，加法就要分n次，每次产生一位和，并且串行逐位的送回寄存器，运行速度太慢。

##### 		串行进位加法器

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317114718192.png" alt="image-20220317114718192" style="zoom:150%;" />

​		把n个全加器串接起来，就可进行两个n位数的相加。

​		又称为行波进位，每一级进位直接依赖于前一级进位，即进位信号是逐级产生的。

##### 		并行加法器

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115154035.png" alt="image-20220317115154035" style="zoom:150%;" />

​		各级进位信号同时产生，又称为先行进位、同时进位。

​		原理：

​		<img src="https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115345816.png" alt="image-20220317115345816" style="zoom:80%;" />![image-20220317115304661](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115304661.png)

##### 		组合

​		![image-20220317115725295](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115725295.png)

​		四个全加器通过并行进位连接起来。

​		![image-20220317115621138](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115621138.png)

​			单级先行进位方式，又称为组内并行，组间串行进位方式。

​		![image-20220317115905841](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220317115905841.png)

​		多级先行进位方式，又称为组内并行、组间并行进位方式。

​		利用CLA电路进行串行的调配。

## 第三章

### 1.存储器与CPU

#### 	1)主存储器

​		基于第一章关于存储器的知识，由地址线连接译码器的一侧，存储体连接译码器的另一侧，MDR连接存储体的输出的那个存储字上，再将地址(MAR)、译码器、MDR连接到控制电路，控制电路连接片选线、读控制线、写控制线。

![Screenshot_20220323_192718_tv.danmaku.bili](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureScreenshot_20220323_192718_tv.danmaku.bili.jpg)

​		片选线：相当于整个芯片的开关，拥有两种模式，高电平有效(电路工作)和低电平有效(电路停止)。

​		读/写控制线：决定本次操作时写进去还是读出来，以及什么时候写进去，什么时候读出来，在一般情况下只有读或者只有写，这两条线可以合并读写控制线。

#### 2)存储器芯片

​		将上述部分封装起来就可以得到一个存储器芯片。

​		逻辑结构如下：

​	![Q图片20220323192505](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccQ%E5%9B%BE%E7%89%8720220323192505.jpg)

#### 	3)寻址

​		在存储体当中，按照不同大小的单元来切分存储器。

​		存放一个字的方式：大端方式(从大到小放置)，小端方式(从大到小放置)

#### 	4)半导体存储芯片的基本结构

![Q图片20220323192505](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccQ%E5%9B%BE%E7%89%8720220323192505.jpg)

​		1.存储矩阵：由大量相同的位存储单元阵列构成。

​		2.译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在写电路的配合下完成对被选中单元的读/写操作。

​		3.读写电路：包括读取放大器和写入电路，用来完成读/写操作。

​		4.读/写控制线：决定芯片进行读/写操作。可以使用一到两根线来完成读写操作。

​		5.片选线：确定哪个存储芯片被选中。可用于容量扩充。

​		6.地址线：是单向的，其位数与存储字的个数有关。

​		7.数据线：是双向的，其位数与读出或写入的数据位数有关。

​		8.数据线数和地址线数共同反映存储芯片容量的大小。

#### 	5)半导体随机存取存储器

![Screenshot_20220323_195513_tv.danmaku.](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccScreenshot_20220323_195513_tv.danmaku..jpg)

​		概念：给出一个地址，只要地址的电信号准备好了，电流迅速流过整个电路，直接给出相应的存储单元，不论这个位于何处，从给出地址信号到取出这个单元所耗费的时间基本一致均为电流流动的时间。即访问所需时间与它所在的物理位置无关。一般用RAM来表示。

​		SRAM为静态随机存储器，DRAM为动态随机存储器。

​		刷新：由于动态随机存储器使用的电容间电荷只能维持2ms，就需要每隔2ms重新将动态随机存储器上的内容重写一遍。

​		注：用途为最后一行。

​		现在的主存主要采取的是SDRAM也就是同步动态随机存储器。

#### 	6)DRAM的刷新

​		刷新周期：一般为2ms

​		每次刷新的大小：以行为单位，每次刷新一行存储单元。

​		相较于之前，将原有的译码器(n->2^n^)改进为一个矩阵的形式防止存储字，分为行译码器和列译码器，大大减少了选通线的数量(由2^n^->2^((n/2)+1)^)。

​		刷新方式：由硬件支持，读出一行的信息后重新写入，占用一个读/写周期。

​				分散刷新：每次读写完都刷新一行。

​				集中刷新：在一定时间内集中安排时间全部刷新，在这段时间内无法访问存储器，被称为“死区”。

​				异步刷新：2ms内刷新一定次数(是存储字的数量)，但每隔一段时间都会有一定时间的“死时间”。

​		7)SRAM的读周期

​			每次间隔都是为使数据稳定下来。

​				读周期：

![Screenshot_20220323_202253_tv.danmaku.bili](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureScreenshot_20220323_202253_tv.danmaku.bili.jpg)

​			写周期：

​					![Screenshot_20220323_202735_tv.danmaku.bili](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureScreenshot_20220323_202735_tv.danmaku.bili.jpg)

#### 8)RAM-易失性存储器

​		失去供电之后就会将内部信息丢失。

​		辅存之类的是不会因断电而丢失信息的。

​		只读存储器(ROM)：断电后不会丢失信息，还可以和CPU进行通信。

​			它的内存不会很大，但是它可以指出操作系统在辅存当中的那个位置，然后将辅存中的OS通过I/O接口调到RAM。

​			ROM用于存放一些开机之后必要的信息，而RAM存放的是正在运行中的程序的信息，因为RAM运行速度快。

#### 9)ROM的发展

​		![Screenshot_20220323_204032_tv.danmaku.bili](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureScreenshot_20220323_204032_tv.danmaku.bili.jpg)

#### 10)存储器

##### 	i.分类

​		按照层次分类：高速缓冲存储器(cache，离CPU最近)、主存储器(主存、内存，离得第二近)，以及不能和CPU直接交流的辅存。

##### 	ii.功能

​		存放二进制信息

​			用不同的材料：磁表面存储器(磁盘或者是磁带)，磁芯存储器、半导体存储器，光存储器(如光盘)

​			使用不同的存储材料，就会有不同的特性，进而产生不同的存取方式和信息的保存性。如半导体是随机存取，存取时间与存储单元位置无关，信息存储易失性(断电丢失)。磁带为顺序存取，只能按照一定的顺序读取，读取时间与其位置有关，非易失性。磁盘为直接存取，先定位到一个较小的区域内，然后在这个较小的区域内进行顺序读取。DRAM的读取方式为破坏性读出，即在读取后内容被破坏，需要进行恢复。而其他的为非破坏性读取。

![image-20220324211436683](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureimage-20220324211436683.png)

#### 11)存储器的性能指标

​	1.存储容量：存储字长×字长

​	2.单位成本：每位价格 = 总成本 / 总容量

​	3.存储速度：数据传输率 = 数据的宽度 / 存储周期

![image-20220324215217024](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureimage-20220324215217024.png)

#### 12)存储器的层次化结构

![image-20220324215430160](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureimage-20220324215430160.png)

​		离CPU远的辅存牺牲了一部分速度来节约成本。

#### 13)存储器芯片的基本结构

​	片选线在芯片中的标注为CS，高电平工作，低电平停止工作。

​	读写工作线的标注是WE，

#### 14)主存容量的扩展

##### 	字扩展

​		线选法：超出地址范围的数据只能为01或10，n条线对应n个片选信号，电路简单，地址空间不连续。

​		译码片选法：通过片选线，n条线连通了2^n^个信号，地址空间可连续，可以增加逻辑设计。

##### 	字位同时扩展

​		把芯片多片作为一组将数据线分别连到数据线的不同位上，先完成位的扩展，然后再借助译码器，在不同的地址空间上选通不同的一组芯片的片选线来进行工作，然后又四组芯片组合起来，四组的开头分别是00、01、10 、11，然后就可以将数据并行的传入到CPU当中。

#### 15)主存与CPU的连接

​	访存控制信号就是决定整个存储器是否工作。

​	系统程序区用ROM，用户程序区用RAM。

​	作图步骤：

​		确认地址线、数据线，选择存储芯片。

​			数据线：CPU数据线根数--->存储器位数扩展数

​			地址分配：计算得出需要的RAM的型号和数量，有的要进行位扩展。

​			地址线：ROM地址线为11根，RAM地址线为10根

​				低地址位直接相连，然后以低位占据最多的向前选择三位，作为三八译码器的左边，剩余的位一般用于作为译码器的使能信号。一半中间跳过的一些位也有作用，与三八译码器的三位一同决定选通信号。

### 2.双端口和多模块

​	可以提高存储器的工作速度

#### 	1)读取周期

​		用来衡量工作速度。

​		![image-20220326150120469](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureimage-20220326150120469.png)

#### 	2)双端口

​		模型：

​			![image-20220326150318612](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/pictureimage-20220326150318612.png)

​		两个端口对同一主存操作有以下四种情况：

​			1.两个端口不同时对同一地址单元存取数据。

​			2.两个端口同时对同一地址单元读取数据。

​			3.两个端口同时对同一地址单元写入数据。		--->可能会导致写入错误

​			4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据。	--->可能会导致写入错误

​	对于上述两种错误的解决方法：

​			加一个控制信号，叫做“忙”信号，由这个控制信号在发生冲突的时候启动控制电路的工作，再由控制电路来判断谁先谁后。这种解决方式对于提速的方式并不是很明显，并且需要提供两套连接线，在硬件上开销较大，应用于两个CPU之间的特殊数据交流。

![image-20220326151404124](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326151404124.png)

![image-20220326151422529](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326151422529.png)

#### 	3)多模块存储器

​		普通的存储器，每行为一个存储单元。

##### 		单体多字存储器

​			存储体依旧是一整个的结构，但是每一行都有多个存储字。

​			这样的模式需要提速的话，需要每个单元存储的字、总线宽度的字和一行并行读出的字相等。

​			但是也就限制了指令和数据必须在内存上是连续存放的。

##### 	多体并行存储器

![image-20220326152053336](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326152053336.png)

​			每个模块都有相同的容量和存取速度。

​			各模块都有独立的读写控制电路、地址寄存器和数据寄存器。

​			既能并行工作，又能交叉工作。

#### 	4)多体并行存储器地址设置方式

​		i.高位交叉编织

​				由地址的高位来决定访问的是哪一个体，地址的低位来决定访问的是体内的哪一块单元。

​				主要是扩容的作用。

​		ii.低位交叉编制

​				由地址的低位来决定访问的是哪一个体，地址的高位来决定访问的是体内的哪一块单元。

​				在第一个存储体启动后，隔一定时间完成存取。第一个完成时间是T，而后面的启动一个一定时间(小于T后)即可完成一个存取任务(不是启动的这个)。可以并行处理，相似于流水线。减少用时。

​				出现这种快捷的条件：模块数大于或等于存储周期与总线传输周期的比值。

![image-20220326154033587](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326154033587.png)

​		编号：

![image-20220326152951723](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326152951723.png)

#### 	5)流水线

##### 		i.微观

​			考计算题(特点：会将每一个参数都说的很清楚)(总线是一系列传输的公用线，宽度一半与字长相等)

​			计算式：![image-20220326154521322](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326154521322.png)

​			例题：!![image-20220326154636297](https://raw.githubusercontent.com/jysj-zjt/small-picture/picture/picture/piccccimage-20220326154636297.png)

##### 			ii.宏观

​			主要是概念题。

​			一个存储周期内，交叉存储器可以提供的数据量为但各模块的m倍。

​		6)补充：多体并行存储器可以并行工作，如总线宽度为mW时，可以同时取出长度为mW的数据。

### 3.高速缓冲存储器

#### 	1)局部性原理

​		空间局部性：在最近的未来要用到的信息(指令和数据)，很有可能与现在正在使用的信息在存储空间上是邻近的。

​		时间局部性：在最近的未来要用到的信息很有可能是现在正在使用的信息。

​		应用：在CPU与主存交流的中间以Cache高速缓冲存储器作为中转，一次性将主存中要取的那个数据以及周围可能会用到的数据一并取出，大大降低了主存与CPU速度严重不符的问题。

#### 2)有关Cache的计算

​	命中率H：CPU欲访问的信息在Cache中的比率。

​		计算：设一个程序执行期间，Cache的总命中次数为N~c~，访问主存的总次数为N~m~，则H = (N~c~/(N~c~+N~m~))

​	缺失率M = 1 - H

​	设t~c~为命中时Cache访问时间，t~m~为未命中时的访问时间。

​	Cache—主存系统的平均访问时间T~a~为：T~a~ = H t~c~ + ( 1 - H ) t~m~ 

​		当题中并未给定具体值时，需要设定一个基准。

​	系统的效率 e = t~Cache~ / T~a~ 



































# 计算机组成原理(书)

## 第一章

​		中央处理单元**CPU**是指计算机系统中负责丛存储器中读该指令并执行指令的部分，在现在基本等价于微处理器。

​		**异常处理**是允许计算机响应外部事件的机制。

​		功耗是计算的关键因素，高性能计算机降低功耗以避免处理器因过热而损坏，便携系统减少功耗而延长电池寿命。

​		计算机系统包括：读取并执行程序的中央处理单元(CPU)，保存程序和数据的存储器，以及将芯片转换实用系统的其他子系统。

​		尽管CPU是计算机的核心，计算机的性能不仅仅取决于CPU，也取决于其他子系统的性能。如果不能够进行高效的数据传输，仅仅提高CPU的性能是无意义的。

​		信息是程序与数据，一般情况下保存于不同的存储器当中，但存储器有多个存储层次(如Cache、主存、辅存等)，尽管每个存储层次都可以存储信息，但是其工作方式却不相同。

​		Cache是用于存放常用数据的高速、专用存储器。

​		主存是指存放大量工作数据，而辅存是指磁盘和CD-ROM(价廉，可储存信息量大)。

​		组成计算机的各个系统是通过总线连接到一起的，数据就可以通过总线从一个地方传递到另外一个地方。

​		可编程计算机接收两种类型的输入：将要处理的数据以及描述对数据处理的程序。(程序只是计算机执行的完成给定任务的操作序列)

​		计算机历史上的第一台计算机并不是通用计算机，只能通过硬连线(指计算机的功能只能通过重新布置线路来实现改变)完成特定的任务。

​		寄存器是CPU内部用来存放数据的存储单元。时钟提供了脉冲流，所有内部操作都在时钟脉冲的触发下进行。

​		时钟频率是决定计算机速度的一个因素。















# C

















# C↑

## 一.概述

### 	1.接口的封装设计

```c++
//初始化网络连接句柄socket,也叫环境初始化
int socketclient_init(void** handle);

//发送报文接口
int socketclient_send(void* handle, unsigned char* buf, int buflen);

//接收报文接口
int socketclient_recv(void* handle, unsigned char* buf, int* buflen);

//socket环境释放
int socketclient_destroy(void** handle);

```

### 	2.过程的封装设计

```c++
//打印函数
void PrintArray(int arr[],int len){

	//打印
	for (int i = 0; i < len; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");

}

void MySort(int arr[],int len){
	//排序
	for (int i = 0; i < len; i++){

		for (int j = len - 1; j > i; j--){

			if (arr[j] < arr[j - 1]){
				int temp = arr[j];
				arr[j] = arr[j - 1];
				arr[j - 1] = temp;
			}

		}

	}
}

void test(){

	int arr[] = { 10, 50, 20, 90, 30 };
	int len = sizeof(arr) / sizeof(int);

	PrintArray(arr, len);
	MySort(arr, len);
	PrintArray(arr, len);
}

```

### 	3.C版本

​		C的版本一般是按照发行年份命名的。

​		最早的C语言标准是被称为K&R  C，于1978年发表。

​			特点：结构体类型、长整型类型、无符号数类型；将=+和=-改为+=和-=。

​		C89/C90是于1989年发行的C语言标准(由美国国家标准协会ANS)

​		C99支持不定长的数组，即数组是可以使用变量定义长度的。

## 二、内容

### 1.数据类型

#### 	1)介绍

​	数据类型是为了对内存进行更好的管理，为了不让内存被严重浪费，让编译器知道该分配多少内存给这个变量或者体。

​	数据类型的基本概念：

​			类型是对数据的抽象；

​			类型相同的数据具有相同的表现形式、存储格式以及相关操作。

​			程序中所有数据必定属于某种数据类型。

​			数据类型可以理解为创建变量的模具或者是固定大小内存的别名。

#### 	2)typedf用法

##### 		i.给结构体起别名

​			typedf struct Person MyPerson;

​		或typedf struct Person{

​			

​			}MyPerson;

##### 		ii.给数据类型起别名

​			如：将char*变为一个数据类型， * 不再寻找最近的变量名：typedf char* PCHAR(可以是任意，一个别名)。

##### 		iii.增强程序的可改性/移植性

​			在某些情况下，一些数据类型在某些地方或许无法使用，或者要将本文档中的某个类型的变量全部重新定义一个类型，如果预先使用过typedf，此时将会十分省事。

#### 	3)void类型

​		void是无类型，void*是无类型指针(在C语言当中可以指向任何类型的数据并自动转换)。

​		void是不可以用来定义变量的，因为编译器无法得知应该分配多大的内存给你的这个变量。

​		void一般用于函数返回的限定以及函数参数的限定。如：

```c
void test(void)//此时不需要返回值以及函数的参数
{
    printf("Hello World!");
}
```

​		任何类型的指针都可以不经过强制转换而转换为void*类型。

​		void*主要用于数据结构的封装。

#### 	4)指针

​		指针就是地址，所以指针的内存大小其实就是计算机中内存的长度。

​		在32位的计算机当中，占4个字节；在64位的计算机当中，占8个字节。

​		CPU是通过地址总线、数据总线、控制总线三条线与内存进行数据传输与操作。

​			地址总线的宽度决定了CPU的寻址能力；

​			控制总线决定了CPU对其他控件的控制能力以及控制方式；

​			数据总线的宽度决定了CPU单次数据传输的传送量，也就是数据传输速度。

#### 		5)sizeof

​			sizeof用于告诉编译器对某变量分配内存的大小，大小以字节为单位。

​			使用方式：

```c
sizeof(变量);
sizeof 变量;
sizeof(类型);
```

​			注意事项：

​				1.sizeof返回的是变量类型占据的空间，而非变量使用的空间。

​				2.返回类型为unsigned int ;unsigned int 进行计算，返回的数据类型也为unsigned int。

​				3.sizeof后＋数组，在一般情况下返回数组的大小(数据类型×数量),但是当数组作为函数的参数时，会变为数组首元素的指针。而sizeof对指针进行使用的时候，一般只会返回4(在32位情况下)。

​				4.由于对齐模式的缘故，sizeof返回的struct的大小比较特别

```c
struct Pp
{
    //在DevC++上运行尝试，仅有int类型为4,仅有char类型为1的倍数，但当int和char同时存在时,char存在便有显示4，但在char为4个及以下的时候，大小不会变化。
    //在结构体前面添加	#pragma pack(1)		即可改变对齐方式，从而使数组大小的反馈改变为char->1。
    int a;
    char b;
    int c;
    double d;
    char e;
};

void test()
{
    printf("Pp size = %d\n",(int)sizeof(Pp));
}
```

对齐模式？？？这是什么大小现在仍未知

#### 		6)变量的间接赋值

​	对内存修改的限制都是由操作系统和编译器添加的。

​		真正的内存并非如此。

```c
void test()
{
    int a = 10;
    //直接赋值
    a = 100;
    
    //间接赋值
    int *p = &a;
    *p = 200;
    
    //取地址赋值
    
}
```

对于指针进行操作:

```c
struct Pp
{
    char a;
    int b;
    char c;
    int d;
};

void test()
{
    struct Pp l = {"a",100,"b",200};//可以使用一个大括号来对结构体进行赋值。
    
    l.d = 1000; //也可以这样，对内存进行修改；
    
    *(int *)((char *)&l + 12)//，&l默认取第一个地址。char*可以控制当后面对这部分进行加操作时只改变一个字节(即偏移多大的地址)，在加操作完成后，将将其转为int*类型(使其的值变为int类型)，然后这是一个指针，在前面加上*变为指针指向地的内容。
        
    int *pp = NULL;
    printf("pp:%d\n",pp);//NULL代表空，地址为0;
    printf("pp+1:%d",pp+1);//数值为0+(数值类型的大小)。
}
```



































# C++

## 注意事项：

​	1.当使用的C++编译器过于旧时无法兼容部分C语言(报错c4996，使用的函数不安全)就要使用下面的代码

​		#define _CRT_SECURE_NO_WARNINGS

## 一.C++概述

### 	1.C++简介

​		C++是对C语言的一种扩展，故C++是C语言的超集。在C++当中 既可以使用C++的特性，并且可以使用C的过程式思维来编写程序。

​		任何有效的C语言程序都是有效的C++程序，C++程序可以使用已有的C语言程序库。

​		C++在C的基础上添加了面向对象编程和泛型编程。

​		C++融合了三种不同的编程方式：C语言代表的过程性语言，C++在C语言基础上添加的类代表的面向对象语言C++模板支持的泛型编程。

### 2.比较

#### 	面向过程

​		以过程为中心的编程思想。

​		思想核心：功能分解，自顶向下，逐层细化(程序=数据结构+算法)

​		缺点：不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。

#### 	面向对象

​		优势：增大了代码重用的几率，更加有利于软件的开发、维护和升级。

​		算法与数据结构被看做是一个整体，称作对象，现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述，所以可以用下面的等式来定义对象和程序：

|                         |
| ----------------------- |
| 对象 = 算法 + 数据结构  |
| 程序 = 对象 + 对象 + …… |

### 3.面向对象的三大特性

​	1)封装

​		把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

​		类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。

​	2)继承

​		继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。

​		继承的作用：避免公用代码的重复开发，减少代码和数据冗余。

​	3)多态

​		多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。

## 二.开始代码

### 1.hello world！

​	初学者的第一个代码(doge)

```c++
#include<iostream>//标准输入输出流  i代表in输入  o代表out输出  stream是流
using namespace std;//使用命名空间 std 相当于在一个大房子中打开一个叫做std的屋子  主要是为了区分同一变量(仅名字相同)所含不同信息在使用时混淆

int main()
{
    cout << "hello world!" << endl;//cout是标准输出
    // <<是左移运算符，在C++中用于拼接字符串或者是数据类型
    //endl是用于结束换行并刷新缓存区
    
    system("pause");//用于阻塞结束，防止出现“一闪而过”的情况。
    
    return 0;//也可以是EXIT_SUCCESS，这个宏的定义就是0，表示成功离开
}
```

​		C++头文件当中并没有.h，而是在前面加上c的前缀，无扩展名。

### 2.双冒号

​		作用于运算符，直接使用 ::是全局作用域。

​		后面加上变量可以使用其全局变量。

### 3.命名空间

​		当有多个使用相同命名的定义时，可以定义不同的命名空间来区别。

```c++
namespace newrange//在namespace后+作用域(自己任意起名，std是属于系统的命名空间)
{
	void goATK();//添加内容
}
```

使用命名好的命名空间的内容(对应上面内容)：

```c++
void newrange::goATK()
{
    cout << "共计实现：" << endl;
}
```

主函数中使用

```c++
int main()
{
    newrange::goATK();
}
```

​		主要用途：用于解决命名冲突问题。

​		命名空间可放置函数、变量、结构体、类等等。

​		命名空间必须作用于全局作用于之下。

​		命名空间可以进行嵌套。

​		命名空间是开放的，随时可以往原先的命名空间添加内容，统一名字的命名空间会自动进行合并，

​		命名空间可以匿名或者无名(namespace时直接进行添加内容，并未命名)。内部的内容相当于写了static，只能在当前文件内使用。

​		命名空间可以起别名。

```c++
namespace newname=oldname;//将旧的名字用新的名字表示，两个名字都表示这个作用域，且都可以使用。
```

### 4.using

#### 	声明

​		例using LOL::sunwukong;且前面有局部变量。

​		使用using声明后表示之后见到的这个变量是使用刚刚由它定义的这个。但是会与编译器自带的就近原则冲突，然后会报错。

#### 	编译指令

```c++
#include<iostream>
using namespace LOL;//用于打开某个区域，当没有局部变量的时候，会就近原则使用这个区域内的对应拥有的数据。
cout << sunwukong << endl;//如果使用using打开多个区域，也要避免二义性的问题。
```

### 5.C++对C的增强

#### 1)全局变量检测增强

​	在C当中：

```c
//定义全局变量时这样写，在C语言当中并不会检测出问题，当然不可以用来在局部变量，会造成重定义。
int a;
int a=10;
```

​	在C++当中：

```c++
//全局变量检测增强，在C++中无法通过，会直接报错
int a;
int a=10;
```

#### 2)函数检测增强

​		C++相对于C检测更加严格

​	包括了：

​		参数类型增强：函数使用的参数必须是定义过类型的，编译器不会自动赋予参数类型。

​		返回值检测增强：C++当中函数必须有返回值。

​		函数调用参数检测增强：C++不会接受超出函数接收范围的值的数量。

​	在C当中：

```c
//可以通过，但无返回值和内容
int getsSc(w,h)
{
	
}
```

​	在C++当中：

```c++
//直接报错，无法通过,必须有一个返回值，而且函数括号内使用参数需要参数类型，不会自动赋予
int getsSc(w,h)
{
	
}
```

#### 3)类型转换检测增强

​	如例一的这段代码，在C中可以通过，因为在C语言中认为malloc函数的返回值为void*为万能值，可任意转换，但在C++中不承认，C++中必须通过强转才可以使用,例二为可通过的状态。

例一：

```c
void test()
{
	char *p = malloc(sizeof(64));//malloc的返回类型为void*
}
```

例二：

```c++
void test()
{
	char *p = (char *)malloc(sizeof(64));
}
```

#### 4)struct增强

​	C语言中struct结构体不可以添加函数，但在C++中可以添加函数。

```c
struct Person
{
    int m_Age;
	void plusAge();//该行会报错，C不支持在结构体内使用函数
};
void test()
{
    struct Person P1;//C语言使用时必须加入struct关键字，C++中可以不写struct
}
```

#### 5)bool类型增强

​		bool类型类似于布尔代数，只有真和假，true为真(1)，false为假(0)，所有非零的数均被转化为真。

​		C语言中不存在bool类型。

#### 6)三目运算符增强

```c++
void test()
{
	int a=10;
	int b=20;
	cout<<"ret="<<a>b?a:b<<endl;//C++输出
	printf("ret=%d\n",a>b?a:b);//C输出
    //在C当中等号左边返回的是一个值，又因为值不能等于值，所以是错误；在C++当中等号左边返回的是变量
	(a>b?a:b)=100;//注意添加上括号
    //C如果要做到和C++上一行一样的效果可以
    *(a>b?&a:&b)=100;
	cout<<"a="<<a<<endl;
	cout<<"b="<<b<<endl;
}
```

#### 7)对于const的增强

​		const作用：给变量设置一个只读的属性，不可以被修改。

​		C中：

```c
const a=10;//在全局区内部，受到保护，不可被修改
void test()
{
	const b=20;//相当于一个伪·常量，且不能用于定义(初始化)数组
	
	int *p=(int *)&b;
	*p=200;//可以被指针进行修改
	printf("*p=%d,b=%d\n",*p,b);
    int arr[b];//不可以初始化数组
}
```

​		C++中：

```c++
void test()
{
	const b=20;//相当于一个(真·)常量，且能用于定义(初始化)数组
	
	int *p=(int *)&b;
	*p=200;//不可以被通过指针修改
	cout<<"*p="<<*p<<endl;
    cout<<"b="<<b<<endl;
    int arr[b];//可以初始化数组
}
```

​		C语言中const修饰的变量是伪常量，但是编译器是会给这个变量分配内存的，只要能分配内存就可以修改。而在C++中const不会分配内存，是会有一个符号表，符号表分为key和value，只有对应到key才能取到值，所以就限定了const修饰的值只会是确定的值；当对const修饰的值进行取地址时，编译器会临时开辟一个内存空间(定义一个变量作为中转)。

### 6.const

#### 	链接性

​	在C中为外部链接：

```C
int main()
{
	extern const int a;//告诉编译器a的值在外部
	printf("a=%d",a);
	return 0;
}
```

```c
const int a=10;//C语言中默认const为外部链接
```

​	在C++中为内部链接：

```c++
int main()
{
    extern const int a;//C++中const为内部链接，外部设置的未添加extern是无法使用的，会报错
    cout<<"a="<<a<<endl;
    system("pause");
    return 0;
}
```

```c++
extern const int a=10;//C++中const为默认内部链接，如要达到外部链接的作用需添加extern来提高作用域
```

#### 	分配内存

​	只要是有内存的量都可以被修改。

​	改变方法：

```c++
void test()
{
    int a=10;
    const int b=a;
    
    int *p = (int *)&b;//利用指针可以绕过检测而将const的值修改
    *p = 100;
    
    cout<<"*p="<<*p<<endl;
    cout<<"b="<<b<<endl;
}
```

​		1.取const的量的时候会临时分配内存；

​		2.在const前添加extern也会分配内存；

​		3.用变量初始化const的变量；

```c++
void test()
{
	int a=10;
	const int b=a;//这时会分配内存
}
```

​		4.用自定义的数据类型

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>
struct Person
{
    string m_Name;
    int m_Age;
};

void test()
{
    const Person*p1;
    /*p1.m_Name="aaa";*/
    //因为是const修饰的类型，无法直接进行修改
    Person *p=(Person*)&p1;
    p->m_Name="德玛西亚";//指针绕过检测进行修改
    (*p).m_Age=18;
    
    cout<<"姓名："<<p1.m_Name<<"年龄："<<p1.m_Age<<endl;
}
```

#### 		尽量以const代替define

​			const是存在作用域的，而define将全部的都替代了，如果只是在这部分使用的话最好用const。

​			const是有类型的，可进行编译器类型安全检查，但是#define并无类型，不可以进行类型检查。

### 7.引用

​		引用就是取别名。

#### 		1)基本语法

​		i)引用基本语法：type  &别名 = 原名

```c++
void test()
{
    int a=10;
    int &b=a;//&在等号左边使用就是引用，右边使用是取地址
    
    b=20;
    
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<<endl;
}
```

​		ii)引用必须初始化，且初始化后无法修改为其他变量的别名

​		iii)对数组建立引用

```c++
void test()
{
    int arr[10];
    for(int i=0;i<10;i++){
        arr[i]=i;
    }
    int (&pArr)[10]=arr;
    for(int i=0;i<10;i++){
        cout<<pArr[i]<<" ";
    }
    cout<<endl;
}
```

​	iv)第二种起别名的方式

​			利用typedef来设定

```c++
void test()
{
    int arr[10];
    for(int i=0;i<10;i++){
        arr[i]=i;
    }
    typedef int(ARRAYR)[10];//一个具有10个元素的int类型的数组
    ARRAYR & pArr = arr;
    for(int i=0;i<10;i++){
        cout<<pArr[i]<<" ";
    }
    cout<<endl;
}
```

#### 	2)注意事项

​		i.引用必须引一块合法的内存空间

```c++
void test()
{
    int &a=10;//10并无内存空间，错误
}
```

​		ii.不要返回局部变量的引用

```c++
int& doWork()
{
    int a=10;
    return a;
}
void test()
{
    int &ret = doWork();
    cout<<"ret="<<ret<<endl;//第一是编译器做了优化，如果后续仍要输出就会出现非所要之数
    cout<<"ret="<<ret<<endl;
}
```

​		如果想要使用的话，将变量不再作为局部变量

```c++
int& doWork()
{
    static int a=10;//将a设置为静态变量
    return a;
}
void test()
{
    int &ret = doWork();
    cout<<"ret="<<ret<<endl;//这次全部为10
    cout<<"ret="<<ret<<endl;
}
```

​		iii.如果一个函数的返回值是引用，那么这个函数调用可以作为左值。

```c++
int& doWork()
{
    static int a=10;
    return a;
}
void test()
{
    doWork()=1000;//相当于写了a=1000
}
```

#### 	3)本质

​		引用的本质是C++内部实现一个**指针常量**。

​		C++编译器在编译过程中使用常指针作为引用的**内部实现**，因此引用所占用的空间大小和指针**相同**，只是这过程是编译器内部实现，用户不可见。

```c++
void testFunc(int& ref)
//发现是引用，转换为int* const ref = &a;
{
    ref = 100;//ref是引用，转换为*ref = 100;
}

int main()
{
    int& aRef = a;//自动转化为int* const aRef=&a,这也就能说明为什么需要进行初始化
    aRef=20;//内部发现aRef是引用，会自动帮我们转换为*aRef=20;
    cout<<"a = "<<a<<endl;
    cout<<"aRef = "<<aRef<<endl;
    system("space");
    testFunc(a);
    return 0;
}
```

#### 	4)指针的引用

​	可以代替一个指针，将二级指针降为一级指针，一级指针将为无指针。

​		复习一下指针：

```c++
struct Person
{
    int m_Age;
};

void allocateMemory(Person ** p)
//**p是具体的Person对象  *p是对象的指针  *p是指针的指针
{
	*p=(Person *)malloc(sizeof(Person));
    (*p)->m_Age = 100;
}

void test()
{
    Person *p = NULL;
    allocateMemory(&p);
    cout<<"年龄="<<p->m_Age<<endl;
}
```

利用指针开辟空间：

```c++
//利用指针开辟空间
void allocateMemoryByRef(Person* &p)//&代替了一个指针
{
    *p=(Person *)malloc(sizeof(Person));
    (*p)->m_Age = 1000;
}
void test()
{
    Person *p = NULL;
    allocateMemoryByRef(p);
    cout<<"年龄="<<p->m_Age<<endl;
}
```

#### 5)常量的引用

​		加上const即可

```c++
void test()
{
	int &ref = 10;//不可以使用，引用了不合法的内存
    const int &ref = 10 ; 
	//可以使用，加入const后，编译器对此过程内部处理为：int tmp = 10;const int &ref = tmp;

	int *p = (int *)&ref;
    *p = 1000;
    
    cout<<"ref="<<ref<<endl;
}
```

​		常量引用使用场景，用来修饰形参

```c++
void showValue(const int &val)
{
    val += 1000;//当只是想展示或者使用该值时加上const就无法被修改，只读。
	cout << "a=" << a << endl;
}

void test()
{
    int a = 10;
    showValue(a);
}
```

​	const引用的使用场景

​		常量引用主要用在函数的形参，尤其是类的拷贝/复制构造函数。

​		将函数的形参定义为常量引用的好处：

​				引用不产生新的变量，减少形参与实参传递时的开销。

​				由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。





### 8.参数的传递方式

​	1)值传递

​		不想改变原区域的值，仅做一些逻辑上的判断时使用

```c++
int mySwap(int a,int b)
{
    int tmp=a;
    a = b;
    b = tmp;
    
    cout<<"mySwap::a="<<a<<endl;
    cout<<"mySwap::b="<<b<endl;
}
void test()
{
    int a = 10;
    int b = 20;
    mySwap(a,b);
    
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<endl;
}
```

​	2)地址传递

​		改变原区域的值

```c++
int mySwap(int *a,int *b)
{
    int tmp=a;
    a = b;
    b = tmp;
    
    cout<<"mySwap::a="<<a<<endl;
    cout<<"mySwap::b="<<b<endl;
}
void test()
{
    int a = 10;
    int b = 20;
    mySwap(&a,&b);
    
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<endl;
}
```

​	3)引用传递

​		类似于地址传递

```c++
int mySwap(int &a,int &b)
{
    int tmp=a;
    a = b;
    b = tmp;
    
    cout<<"mySwap::a="<<a<<endl;
    cout<<"mySwap::b="<<b<endl;
}
void test()
{
    int a = 10;
    int b = 20;
    mySwap(a,b);
    
    cout<<"a="<<a<<endl;
    cout<<"b="<<b<endl;
}
```

### 9.类(class)

​		class是一种声明

​		类与对象的关系：类是对对象的抽象，对象是对类的实例。

设计圆类：

```c++
//设计圆类
class Circle//class代表声明一个类，后面紧跟的是类的名称
{
    public://公共权限，如果没有这个的话，在这个类的外部是无法访问到内部的成员的
    
//求圆的周长
    //在类里面写函数，一般称为其成员函数
    double calculateZC()
    {
        return 2 * pi * m_R ; 
    }
    
    //设置半径的成员方法
    //成员函数可以修改成员属性
    void setR(int r)
    {
        m_R = r;
    }
    
    //半径，成员属性，可以在成员函数中直接使用
    int m_R;
}

void test()
{
    //通过 类 来创建一个圆
    Circle c1;//圆(叫做对象)
    c1.m_R = 10;
    
    //通过成员函数间接给圆设置半径
    c1.setR(10);
    
    //输出c1的周长
    cout << "c1的周长为：" << c1.calculateZC() << endl;
}
```

设计学生类：

```c++
#include<iostream>
#include<string>
class Student
{
public://公共权限
    
    //设置姓名
    void setName(string name)
    {
        m_Name = name;
    }
    
    //设置学号
    void setId(int id)
    {
        m_Id = id;
    }
    
    //打印信息
    void showInformation()
    {
        cout << "姓名：" << m_Name << "学号：" << m_Id <<endl;
    }
    
    string m_Name;//姓名
    int m_Id;//学号
}

void test()
{
    //创建一个学生 ---> 实例化：通过类来创建对象的过程
    Student st;
    st.setName("张三");
    set.setId(1);
    
    cout << "st的姓名为：" << st.m_Name <<"st的学号为：" << st.m_Id << endl;
    
    //通过成员函数来打印信息
    
}
```

### 10.内联函数

#### 	1)产生原因

​		预处理的宏存在缺陷，所以为了代替宏，创建了内联函数。

​		

```c++
//定义一个加法
#define MyAdd(x,y) x+y//此处存在一个缺陷，当有乘法在其后时，就会变成x+y*m,而不是预想当中的(x+y)*m,应该改为((x) + (y))这样的形式

#define MyCompare(a,b) ((a) < (b)) ?(a):(b)

void test1()
{
    int ret = MyAdd(10,20);
    
    cout << "ret = " << ret << endl;
}

void test2()
{
    int a = 10;
    int b = 20;
    int ret = MyCompare(a,b);//再添加上括号之后，就这样的运行是没错的，但是如果将a改为++a时，就会运行++a两次，导致a+2，而不是预期当中的a+1
    cout << "ret = " << ret << endl;
}

//宏函数而且没有作用域
```

#### 2)基本概念

​		在函数前面添加inline使函数变为内联函数。

​		与宏定义基本一致。

​		注意事项：

```c++
//内联函数注意事项
inline void func()//定义与实现如果分开的话都需要inling的声明
```

​		内联函数依旧会占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以时间换空间。

​		类内部的成员函数默认在前面会添加inline关键字。

day02-04-17:00左右

































# Java









# Python











# 代码随想录

